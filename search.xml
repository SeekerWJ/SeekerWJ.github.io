<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STM32直流电机驱动与编码器测速</title>
    <url>/2021/01/17/STM32%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E4%B8%8E%E7%BC%96%E7%A0%81%E5%99%A8%E6%B5%8B%E9%80%9F/</url>
    <content><![CDATA[<h1 id="1-什么是编码器"><a href="#1-什么是编码器" class="headerlink" title="1.什么是编码器"></a>1.什么是编码器</h1><p>​    编码器是一种将角位移或者角速度转换成一连串电数字脉冲的旋转式传感器，我们可以通过编码器测量到底位移或者速度信息。编码器从输出数据类型上分，可以分为增量式编码器和绝对式编码器。<br>​    从编码器检测原理上来分，还可以分为光学式、磁式、感应式、电容式。常见的是光电编码器（光学式）和霍尔编码器（磁式）。 </p>
<p>​    这里使用的编码器就是霍尔编码器</p>
<h1 id="2-编码器原理"><a href="#2-编码器原理" class="headerlink" title="2.编码器原理"></a>2.编码器原理</h1><p>​    光电编码器是一种通过光电转换将输出轴上的机械几何位移量转换成脉冲或数字量的传感器。光电编码器是由光码盘和光电检测装置组成。光码盘是在一定直径的圆板上等分地开通若干个长方形孔。由于光电码盘与电动机同轴，电动机旋转时，检测装置检测输出若干脉冲信号，为判断转向，一般输出两组存在一定相位差的方波信号。 </p>
<p>​    霍尔编码器是一种通过磁电转换将输出轴上的机械几何位移量转换成脉冲或数字量的传感器。霍尔编码器是由霍尔码盘和霍尔元件组成。霍尔码盘是在一定直径的圆板上等分地布置有不同的磁极。霍尔码盘与电动机同轴，电动机旋转时，霍尔元件检测输出若干脉冲信号，为判断转向，一般输出两组存在一定相位差的方波信号。 </p>
<p>​     可以看到两种原理的编码器目的都是获取AB相输出的方波信号，其使用方法也是一样，下面是一个简单的示意图。 </p>
<img src="https://z4a.net/images/2021/01/16/20200725161723303.png" alt="20200725161723303.png" style="zoom:67%;">

<a id="more"></a>

<h1 id="3-编码器接线说明"><a href="#3-编码器接线说明" class="headerlink" title="3.编码器接线说明"></a>3.编码器接线说明</h1><img src="https://z4a.net/images/2021/01/16/20200725161759680.png" alt="20200725161759680.png" style="zoom:50%;">

<p>​    这是一款增量式输出的霍尔编码器。编码器有AB相输出，所以不仅可以测速，还可以辨别转向。根据上图的接线说明可以看到，只需给编码器电源5V供电，在电机转动的时候即可通过AB相输出方波信号。编码器自带了上拉电阻，所以无需外部上拉，可以直接连接到单片机IO读取。 </p>
<h1 id="4-编码器的四倍频计数"><a href="#4-编码器的四倍频计数" class="headerlink" title="4.编码器的四倍频计数"></a>4.编码器的四倍频计数</h1><p>​    这是一项实用的技术，可以真正地把编码器的精度提升4倍。作用可类比于单反相机的光学变焦，而并非牺牲清晰度来放大图像的数码变焦。 </p>
<img src="https://z4a.net/images/2021/01/17/20200725161906256.png" alt="20200725161906256.png" style="zoom:67%;">

<p>​    常规的方法，我们只测量A相（或B相）的上升沿或者下降沿，也就是上图中对应的数字1234中的某一个，这样就只能计数3次。而四倍频的方法是测量A相和B相编码器的上升沿和下降沿。这样在同样的时间内，可以计数12次（3个1234的循环）。这就是四倍频的原理。 </p>
<p>​    这里的话不建议采用利用IO口中断的方式来采集脉冲，这样会过于占用单片机资源</p>
<p>​    STM32正好就带有编码器接口，这样操作起来会方便很多</p>
<h1 id="5-STM32-TIM-编码器模式配置"><a href="#5-STM32-TIM-编码器模式配置" class="headerlink" title="5.STM32 TIM 编码器模式配置"></a>5.STM32 TIM 编码器模式配置</h1><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**************************************************************************
函数功能：把TIM2初始化为编码器接口模式
入口参数：无
返回  值：无
**************************************************************************/</span>
<span class="token keyword">void</span> <span class="token function">Encoder_Init_TIM2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure<span class="token punctuation">;</span>  
  TIM_ICInitTypeDef TIM_ICInitStructure<span class="token punctuation">;</span>  
  GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>
  <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使能定时器2的时钟</span>
  <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使能PA端口时钟</span>

  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_0<span class="token operator">|</span>GPIO_Pin_1<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//端口配置</span>
  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IN_FLOATING<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//浮空输入</span>
  <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//根据设定参数初始化GPIOA</span>

  <span class="token function">TIM_TimeBaseStructInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TIM_TimeBaseStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
  TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 预分频器 </span>
  TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> ENCODER_TIM_PERIOD<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//设定计数器自动重装值</span>
  TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> TIM_CKD_DIV1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//选择时钟分频：不分频</span>
  TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//TIM向上计数  </span>
  <span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">TIM_EncoderInterfaceConfig</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_EncoderMode_TI12<span class="token punctuation">,</span> TIM_ICPolarity_Rising<span class="token punctuation">,</span> TIM_ICPolarity_Rising<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用编码器模式3</span>

  <span class="token function">TIM_ICStructInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
  TIM_ICInitStructure<span class="token punctuation">.</span>TIM_ICFilter <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token function">TIM_ICInit</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_ICInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">TIM_ClearFlag</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_FLAG_Update<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">//清除TIM的更新标志位</span>
  <span class="token function">TIM_ITConfig</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> TIM_IT_Update<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//使能TIM2的中断，防止计数溢出</span>

  <span class="token function">TIM_SetCounter</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM2<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**************************************************************************
函数功能：单位时间读取编码器计数
入口参数：定时器
返回  值：速度值
**************************************************************************/</span>
<span class="token keyword">int</span> <span class="token function">Read_Encoder</span><span class="token punctuation">(</span>u8 TIMX<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> Encoder_TIM<span class="token punctuation">;</span>    
    <span class="token keyword">switch</span><span class="token punctuation">(</span>TIMX<span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>  Encoder_TIM<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>TIM2 <span class="token operator">-></span> CNT<span class="token punctuation">;</span>  TIM2 <span class="token operator">-></span> CNT<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>  Encoder_TIM<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>TIM3 <span class="token operator">-></span> CNT<span class="token punctuation">;</span>  TIM3 <span class="token operator">-></span> CNT<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    
        <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>  Encoder_TIM<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>TIM4 <span class="token operator">-></span> CNT<span class="token punctuation">;</span>  TIM4 <span class="token operator">-></span> CNT<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    
        <span class="token keyword">default</span><span class="token punctuation">:</span> Encoder_TIM<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Encoder_TIM<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**************************************************************************
函数功能：TIM2中断服务函数
入口参数：无
返回  值：无
**************************************************************************/</span>
<span class="token keyword">void</span> <span class="token function">TIM2_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                                       
    <span class="token keyword">if</span><span class="token punctuation">(</span>TIM2<span class="token operator">-></span>SR<span class="token operator">&amp;</span><span class="token number">0X0001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//溢出中断</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        TIM2<span class="token operator">-></span>SR<span class="token operator">&amp;</span><span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//清除中断标志位 </span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                            
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h1 id="6-速度计算方法"><a href="#6-速度计算方法" class="headerlink" title="6.速度计算方法"></a>6.速度计算方法</h1><p> 这里计算的是真实的电机轮子的物理转速</p>
<p> 电机转动一圈的脉冲数：num1 单位：个 </p>
<p> 单位时间：t 单位：秒 </p>
<p> 单位时间内捕获的脉冲变化数：num2 单位：个 （反应电机正反转） </p>
<p> 电机轮子半径：r 单位：m </p>
<p> 速度：speed 单位： mm/s<br>$$<br>Speed = 1000<em>num2</em>(2<em>pi</em>r/num1)/t<br>$$</p>
<h1 id="7-PWM驱动直流电机及1S中断配置"><a href="#7-PWM驱动直流电机及1S中断配置" class="headerlink" title="7.PWM驱动直流电机及1S中断配置"></a>7.PWM驱动直流电机及1S中断配置</h1><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">TIM3_Int_Init</span><span class="token punctuation">(</span>u16 arr<span class="token punctuation">,</span>u16 psc<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure<span class="token punctuation">;</span>

    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM3<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//时钟使能</span>

    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> arr<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//设置在下一个更新事件装入活动的自动重装载寄存器周期的值     计数到5000为500ms</span>
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span>psc<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//设置用来作为TIMx时钟频率除数的预分频值  10Khz的计数频率  </span>
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//不分频</span>
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//TIM向上计数模式</span>
    <span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</span>

    <span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使能TIM3外设</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">TIM4_Int_Init</span><span class="token punctuation">(</span>u16 arr<span class="token punctuation">,</span>u16 psc<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure<span class="token punctuation">;</span>

    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM4<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//时钟使能</span>

    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> arr<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//arr为999 psc为71 就是1ms的中断溢出</span>
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span>psc<span class="token punctuation">;</span>  
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>  
    <span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token function">TIM_ITConfig</span><span class="token punctuation">(</span>TIM4<span class="token punctuation">,</span>TIM_IT_Update <span class="token punctuation">,</span>ENABLE <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//开启TIM4中断</span>

    <span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM4<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使能TIM4外设</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">TIM4_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>                                                       <span class="token comment" spellcheck="true">//TIM4中断回调函数</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TIM_GetITStatus</span><span class="token punctuation">(</span>TIM4<span class="token punctuation">,</span> TIM_IT_Update<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//检查指定的TIM中断发生与否</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            time<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>time <span class="token operator">==</span> <span class="token number">1000</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                Encoder <span class="token operator">=</span> <span class="token function">Read_Encoder</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token function">TIM_ClearITPendingBit</span><span class="token punctuation">(</span>TIM4<span class="token punctuation">,</span> TIM_IT_Update<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//清除TIMx的中断待处理位        </span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">TIM3_PWM_Init</span><span class="token punctuation">(</span>u16 arr<span class="token punctuation">,</span>u16 psc<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  
    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>
    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure<span class="token punctuation">;</span>
    TIM_OCInitTypeDef  TIM_OCInitStructure<span class="token punctuation">;</span>


    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM3<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使能定时器3时钟</span>
     <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//使能GPIO外设时钟</span>

    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_6<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//CH1</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_PP<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//复用推挽输出</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>
    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">//初始化GPIO</span>

  <span class="token comment" spellcheck="true">//初始化TIM3</span>
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> arr<span class="token punctuation">;</span> 
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span>psc<span class="token punctuation">;</span>  
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    TIM_TimeBaseStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>  
    <span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_TimeBaseStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//初始化TIM3 CHl PWM模式     </span>
    TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OCMode <span class="token operator">=</span> TIM_OCMode_PWM1<span class="token punctuation">;</span> 
     TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OutputState <span class="token operator">=</span> TIM_OutputState_Enable<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//比较输出使能</span>
    TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OCPolarity <span class="token operator">=</span> TIM_OCPolarity_High<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//输出极性:TIM输出比较极性高</span>
    <span class="token function">TIM_OC1Init</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TIM_OCInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>                                          <span class="token comment" spellcheck="true">//根据T指定的参数初始化外设TIM3 OC1</span>

    <span class="token function">TIM_OC1PreloadConfig</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_OCPreload_Enable<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使能TIM3在CCR1上的预装载寄存器</span>

    <span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使能TIM3</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<hr>
<h1 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h1><img src="https://z4a.net/images/2021/01/17/1610648473170.gif" alt="1610648473170.gif" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/17/1610829367881.gif" alt="1610829367881.gif" style="zoom:50%;">





















]]></content>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32通用定时器驱动SG90舵机</title>
    <url>/2020/09/24/STM32%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E9%A9%B1%E5%8A%A8SG90%E8%88%B5%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="SG90舵机的控制原理"><a href="#SG90舵机的控制原理" class="headerlink" title="SG90舵机的控制原理"></a>SG90舵机的控制原理</h2><p>舵机的控制一般需要一个20ms的时基脉冲，该脉冲的高电平部分一般为0.5ms~2.5ms范围内的角度控制脉冲部分。以180度角度舵机为例，那么对应的控制关系是这样的： </p>
<p>0.5ms————-0度；<br>1.0ms————45度；<br>1.5ms————90度；<br>2.0ms———–135度；<br>2.5ms———–180度； </p>
<p><img src="https://s1.ax1x.com/2020/09/24/0SubZR.gif" alt="0SubZR.gif"></p>
<p>所以，通过单片机输出相应的PWM信号即可控制舵机旋转相应的角度</p>
<a id="more"></a>

<h2 id="STM32通用定时器输出PWM信号配置"><a href="#STM32通用定时器输出PWM信号配置" class="headerlink" title="STM32通用定时器输出PWM信号配置"></a>STM32通用定时器输出PWM信号配置</h2><h3 id="定时器周期计算公式："><a href="#定时器周期计算公式：" class="headerlink" title="定时器周期计算公式："></a>定时器周期计算公式：</h3><p>T = （（Prescaler + 1） * （Period + 1） ） / TimeClockFren; </p>
<p>Prescaler：分频TIM时钟的预分频器值。 </p>
<p>Period：计数重载值，TIM计数当超过这个值，则重新计数。</p>
<p>TimeClockFren：定时器的输入时钟频率（单位MHZ），也就是当前使用的TIM所用的CLOK的时钟频率。 这里为72Mhz</p>
<p>需要20ms的时基脉冲 20ms = (7200*200)/72000000=0.02 </p>
<p>所以TIM_Period = 199，TIM_Prescaler = 7199 </p>
<h3 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pwm_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//声明一个结构体变量，用来初始化GPIO</span>

    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//声明一个结构体变量，用来初始化定时器</span>

    TIM_OCInitTypeDef TIM_OCInitStructure<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据TIM_OCInitStruct中指定的参数初始化外设TIMx</span>

    <span class="token comment" spellcheck="true">/* 开启时钟 */</span>
    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOC<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB1Periph_TIM3<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/*  配置GPIO的模式和IO口 */</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin<span class="token operator">=</span>GPIO_Pin_6<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// PA6</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed<span class="token operator">=</span>GPIO_Speed_50MHz<span class="token punctuation">;</span>
    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode<span class="token operator">=</span>GPIO_Mode_AF_PP<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//复用推挽输出</span>
    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span><span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//TIM3定时器初始化</span>
    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Period <span class="token operator">=</span> <span class="token number">199</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//PWM 频率=72000/(199+1)=36Khz//设置自动重装载寄存器周期的值</span>
    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_Prescaler <span class="token operator">=</span> <span class="token number">7199</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置用来作为TIMx时钟频率预分频值</span>
    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_ClockDivision <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置时钟分割:TDTS = Tck_tim</span>
    TIM_TimeBaseInitStructure<span class="token punctuation">.</span>TIM_CounterMode <span class="token operator">=</span> TIM_CounterMode_Up<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//TIM向上计数模式</span>
    <span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token operator">&amp;</span> TIM_TimeBaseInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//PWM初始化      //根据TIM_OCInitStruct中指定的参数初始化外设TIMx</span>
    TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OCMode<span class="token operator">=</span>TIM_OCMode_PWM1<span class="token punctuation">;</span>
    TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OutputState<span class="token operator">=</span>TIM_OutputState_Enable<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//PWM输出使能</span>
    TIM_OCInitStructure<span class="token punctuation">.</span>TIM_OCPolarity<span class="token operator">=</span>TIM_OCPolarity_Low<span class="token punctuation">;</span>

    <span class="token function">TIM_OC1Init</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span><span class="token operator">&amp;</span>TIM_OCInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//注意此处初始化时TIM_OC1Init而不是TIM_OCInit，否则会出错。因为固件库的版本不一样。</span>
    <span class="token function">TIM_OC1PreloadConfig</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> TIM_OCPreload_Enable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使能或者失能TIMx在CCR1上的预装载寄存器</span>
    <span class="token function">TIM_Cmd</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使能或者失能TIMx外设</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>这里TIM_OCInitTypeDef.TIM_Pulse不用配置，而是在主函数中通过TIM_SetCompare1(TIMx,x)函数来修改他的值，已达到想要转动舵机角度的目的</p>
<p><em>TIMx_CCRx寄存器能够在任何时候通过软件进行更新以控制波形，这个通过软件写入控制波形的值是立即生效呢还是在定时器发生下一次更新事件时被更新的，是由TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_Enable)这条语句决定的！Enable就是下一次更新事件时被更新；Disable是立即生效</em></p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* 定时器初始化 */</span>
    <span class="token function">pwm_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token function">TIM_SetCompare1</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token number">195</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0度</span>
        <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">TIM_SetCompare1</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//90度</span>
        <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">TIM_SetCompare1</span><span class="token punctuation">(</span>TIM3<span class="token punctuation">,</span> <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//180度</span>
        <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>最终效果如图</p>
<p><img src="https://s1.ax1x.com/2020/09/24/0SKGWT.gif" alt="0SKGWT.gif"></p>
]]></content>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>深深的进入当下1</title>
    <url>/2021/01/12/%E6%B7%B1%E6%B7%B1%E7%9A%84%E8%BF%9B%E5%85%A5%E5%BD%93%E4%B8%8B1/</url>
    <content><![CDATA[<h2 id="不在思维中寻找自己"><a href="#不在思维中寻找自己" class="headerlink" title="不在思维中寻找自己"></a>不在思维中寻找自己</h2><ul>
<li>思维认同，它创造了一个虚假的自我，也就是小我，而这个虚假的自我替代了你真正的自我。而你真正的自我是根植与本体之中的。</li>
<li>小我的需求是无止尽的。它感到自己很脆弱，容易受到威胁，所以他一直生活在一种恐惧和缺乏的状态中。</li>
<li>小我喜欢将各种各样的的问题都转化为复杂的个人问题，它喜欢将自己与你的问题联系在一起，通过这种依托关系以便于加强它虚幻的自我感。所以，小我喜欢你无意识的大量地投资在痛苦和苦难中。</li>
<li>一旦认识到无意识的根本原因是思维认同和情感认同，你就可以逐步走出这个阴影了。你可以进入当下，这时，你就会允许思维的存在而不陷思维的陷阱中了。思维本身是个很好的工具，但不要从大脑思维中寻找自己，并认为它就是我自己，如果那样的话，他就会变成一种小我的思维，并且控制你的整个生活。</li>
</ul>
<a id="more"></a>

<h2 id="终结时间的幻象"><a href="#终结时间的幻象" class="headerlink" title="终结时间的幻象"></a>终结时间的幻象</h2><ul>
<li><p>时间和思维是密不可分的，从思维中去除时间，思维就会停止————除非你运用它。</p>
</li>
<li><p>当你与思维认同时，你就陷入了时间的陷阱，你会不由自主的完全生活在对过去的回忆和对未来的期待或恐惧之中。这样你的心思就会完全被过去和未来占据，而不愿意接收当下的时刻。实际上这两者都是幻象。</p>
</li>
<li><p>时间一点也不珍贵，因为他只是一种幻象。珍贵的东西不是时间，而是不在时间内的那一点，即当下。当下才是唯一珍贵的东西，因为作为生物来说，整个生命都是在这个永恒当下空间中展开的。</p>
</li>
<li><p>当下这一刻，当时间缺席时，你所有的问题都会消失。苦难只有在时间中才能存在，在当下它无法存活。</p>
</li>
</ul>
<h2 id="任何事物都不可能存在于当下时刻之外"><a href="#任何事物都不可能存在于当下时刻之外" class="headerlink" title="任何事物都不可能存在于当下时刻之外"></a>任何事物都不可能存在于当下时刻之外</h2><ul>
<li><p>没有任何事情可以发生在过去，也没有任何事情可以发生在未来，所有事情只能发生在当下。过去发生的事情是一个记忆的痕迹，它存储在大脑中，是过去的当下。当你记起过去发生的那件事，你就重新激活了那个记忆————而你是在当下做的这件事情。未来也只是一个幻象的当下，是思维对未来的投射。当未来来临时，它也是以当下的形式到来。当你思考未来时，你也是在当下做这件事。</p>
</li>
<li><p>过去和未来都没有现实性，就像月亮本来就不会发光一样，他只能反射太阳光，所有过去和未来仅是永恒当下的光线，力量和现实性的反射。过去和未来的现实性，力量都是从当下借过来的。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>深深的进入当下2</title>
    <url>/2021/01/14/%E6%B7%B1%E6%B7%B1%E7%9A%84%E8%BF%9B%E5%85%A5%E5%BD%93%E4%B8%8B2/</url>
    <content><![CDATA[<h2 id="汲取当下的力量"><a href="#汲取当下的力量" class="headerlink" title="汲取当下的力量"></a>汲取当下的力量</h2><ul>
<li>无时间状态可以转变人类的感知。但是光有体验是不够的，不论他是多么美好或者深刻，。我们需要的和所关注的是意识层面的永久转变。</li>
<li>把对当下时刻的意识作为一种习惯，当不需要关注过去和未来的时候，请把你的注意力从他们之中解放出来。</li>
<li>在日常生活中，尽可能的从时间的意识中把自己解放出来。如果发现很难直接进入当下时刻，那么请你观察自己老想要脱离当下时刻的惯性开始。这样你将会体会到，你总是吧未来看的比现在更好或更坏。如果想象的未来比现在好，它会给你希望，或者让你愉悦地期待；如果他比现在更糟糕，则会让你焦虑————其实这二者都是幻象。</li>
<li>通过自我观察，更多的临在意识会自动的进入你的生活当中。当你意识到自己没有在当下的那一刻起，你就在当下了。</li>
</ul>
<a id="more"></a>

<ul>
<li><p>任何时候，当你有能力观察你的思维时，你就不会再落入时间的陷阱了。这时，另外一个不属于思维的东西就来临了：观察者的临在。</p>
<ul>
<li><p>保持临在，随时观察你的思维，想法，情绪以及在各种情况下你的反应。请多关注自己对各种人，事，物的反应。</p>
</li>
<li><p>同时关注你的注意力是否常常跑到过去或者未来之中。不要去分析或者判断你所观察到的内容，就只是观察你的想法，感受你的情绪，关注你的反应，而不要把他们变成个人的问题。</p>
</li>
<li><p>这样你将会感受到一些比你所有观察到的更为有力量的东西：在思维背后，那个宁静的，观察临在的本身————宁静的观察者。</p>
</li>
</ul>
</li>
<li><p>思维认同给予了思维更多的能量，对思维的观察却能把能量撤回；思维认同创造了更多的时间，对思维的观察却能开启无时间的领域。而这些从思维中撤回的能量就会转变为临在。</p>
</li>
<li><p>这一切实际上就是学会对思维的控制。即，学会了如何向思维注入和收回能量</p>
</li>
</ul>
<h2 id="摆脱心理时间"><a href="#摆脱心理时间" class="headerlink" title="摆脱心理时间"></a>摆脱心理时间</h2><ul>
<li><p>所谓钟表时间就是在生活中实际事务上的利用时间。钟表时间不仅仅是用来安排约会或者计划任务的。它还包括从过去中吸取经验教训。使我们不会一次又一次的犯相同的错误。包括设定目标向其迈进；还包括以规律，法则，物理数学等方式预测未来并从过去汲取经验教训，同时在预测的基础上采取合适的行动</p>
</li>
<li><p>所谓心理时间就是认同过去，并且持续地，强迫地投射到未来</p>
</li>
<li><p>开悟的人通常会将注意力集中在当下，但是他们对时间的关注仍然同时在进行着。换句话说，他们会继续利用钟表时间，但是他们会将自己从心理时间上解脱出来。</p>
</li>
<li><p>当你设定了目标并且努力的去实现它，那么你是在利用钟表时间。你知道你的目标，但是你也全力地关注你当下时刻采取的行动。然而，若是你过于注重目标，或许因为你在寻找幸福或者成就感，成为一个更圆满的自我感，这时你就没有在关注当下了。当下失去了固有的价值，而沦为通向未来的踏脚石。这样钟表时间就变成了心理时间。</p>
</li>
<li><p>如何在利用钟表目标的过程中又不过于关注结果呢？这实际上就是进入临在状态后（进入临在状态是前提，只有处在临在状态下才能控制能量的流转）控制能量的问题。在需要钟表时间的时候向其注入能量，即，对目标思维认同，而查看完成之后观察思维本身收回能量，专注于当下。</p>
</li>
</ul>
<h2 id="消极心态和痛苦根植于时间之中"><a href="#消极心态和痛苦根植于时间之中" class="headerlink" title="消极心态和痛苦根植于时间之中"></a>消极心态和痛苦根植于时间之中</h2><ul>
<li><p>一般来说，未来是过去的复制品。表面变化是有可能发生的，但是真正的变化却很少发生，这主要依赖于你是否能充分保持临在，并通过汲取当下的力量来解决过去的事情。</p>
</li>
<li><p>你对未来的看法是你当下意识状态不可分的一部分。如果你的思维背负着过去的沉重负担，未来你将会体验更多的相同负担。由于缺乏临在，过去还会侵入你的思维。你在当下的时刻的意识的质量影响着你的未来，而未来，当然只能在当下里经历。</p>
</li>
<li><p>真正能够发生变化以及瓦解过去的唯一地方就是当下</p>
</li>
<li><p>所有的消极心态都是由积累了心理时间以及对当下时刻的拒绝所引起的。焦虑，紧张，不安，压力，烦恼————所有形式的恐惧，都是因为对未来过于关注而对当下关注不够所引起的。愧疚，后悔，悲伤，怨恨，痛苦以及所有形式的不宽恕都是由过于关注过去而很少关注当下时刻引起的。</p>
</li>
<li><p>除非解决了大脑不断制造麻烦的功能失调问题，否则所有的麻烦都会换汤不换药的重复出现。如果造成你所有问题，痛苦，不幸的原因都在今天奇迹般的消失，但是你还是没有变得更为临在，更有意识，那你很快就会发现同样的问题或痛苦的原因又会如影随形般的出现在你身边。最终，问题只有一个：被时间所限的思维本身。</p>
</li>
<li><p>我无法相信，我有朝一日能从问题中完全的释放出来。其实你是对的，在时间中永远无法达成这种状态，因为你已经在那个时间点上了。那就是现在！在时间中没有救赎。你无法在未来被释放，当下时刻才是你获取自由的关键，所以你只有在当下才能解脱。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>深深的进入当下3</title>
    <url>/2021/01/20/%E6%B7%B1%E6%B7%B1%E7%9A%84%E8%BF%9B%E5%85%A5%E5%BD%93%E4%B8%8B3/</url>
    <content><![CDATA[<h2 id="所有问题都是时间的幻象"><a href="#所有问题都是时间的幻象" class="headerlink" title="所有问题都是时间的幻象"></a>所有问题都是时间的幻象</h2><h3 id="“也许我进入了当下，感到一个沉重的负担被卸下来了，顿时浑身轻松。我感觉到很清晰，但是仍然有许多问题在等待着我，不是吗？它们都还没有得到解决，我难道不是在暂时逃避这些问题吗？”"><a href="#“也许我进入了当下，感到一个沉重的负担被卸下来了，顿时浑身轻松。我感觉到很清晰，但是仍然有许多问题在等待着我，不是吗？它们都还没有得到解决，我难道不是在暂时逃避这些问题吗？”" class="headerlink" title="“也许我进入了当下，感到一个沉重的负担被卸下来了，顿时浑身轻松。我感觉到很清晰，但是仍然有许多问题在等待着我，不是吗？它们都还没有得到解决，我难道不是在暂时逃避这些问题吗？”"></a>“也许我进入了当下，感到一个沉重的负担被卸下来了，顿时浑身轻松。我感觉到很清晰，但是仍然有许多问题在等待着我，不是吗？它们都还没有得到解决，我难道不是在暂时逃避这些问题吗？”</h3><ul>
<li><p>这些与解决你的问题无关，而是要认识到现在没有任何问题。只有一些需要在当下处理掉，或者顺其发展并把它看作是当下本然面目一部分的某些情景，知道他们发生变化或可以处理了，采取采取行动。问题是思维创造的，它们需要时间来生存。在当下时刻的现实情况下，它们是无法生存的。现在把注意力集中在当下，你会发现当下时刻你不会有任何问题</p>
</li>
<li><p>一个新的情景出现时，我们要么去应付他，要么就是去接受它，对它说”好的”。为什么要把它转变成一个问题呢？为什么要将任何事情都转变成问题呢？难道生活中的挑战还不够多吗？你需要问题来做什么呢？</p>
</li>
<li><p>思维会无意识的喜欢上问题，因为他们给你某种身份的认同。这是正常的同时也是病态的。“问题”的意思是，你在心理上不断地琢磨某种情况，而没有真正地在当下采取行动，并且你还无意识的将它变成你自我感觉的一部分。你被你的生活情境所累倒，以至于丧失了对生命的感觉，存在的感觉。或者，你大脑中背负着100件你在未来将会或必须做的事情的重担，却没有将注意力集中在一件你现在就能做的事情上。</p>
</li>
<li><p>如果你曾处于生死关头的紧急情况，你就会知道那不是个问题。思维没有时间来得及使它成为一个问题。在真正的紧急情况下，思维停止了；你完全临在于当下，被一种更为有力的东西接管了。这就是许多普通人突然能够做出令人难以置信的事的原因。在任何紧急情况下，你要么生存，要么死亡。无论何者，他都不是一个问题。简而言之就是Do or Die.</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li>也许人们会气愤，为什么说问题只是一种幻象。因为他们是谁的感觉受到了威胁。他们将大量时间投入在一种虚假的自我感上。多年以来，他们无意识地将自我认同与他们的问题和痛苦结合起来。如果没有了这些问题和痛苦，他们将会是谁呢？</li>
<li>人们所说的，所思考的，所做的很多事情实际上都源自于恐惧，当然，这还与他们对未来的关注以及与当下时刻的脱离有关。如果当下没有问题，那么也就没有恐惧。</li>
<li>如果出现了你现在就需要解决的问题，而你的行动是产生于当下的觉知，那么它们就会很果断，很清晰，并更有效。这种反应不是来源于你过去的思维模式，而是来源于对问题的直觉反应。在其他情况下，如果被时间限制的思维模式做出了反应，你就会发现：什么都不做，在当下归于中心反而更有效。</li>
</ul>
<h2 id="本体的喜悦"><a href="#本体的喜悦" class="headerlink" title="本体的喜悦"></a>本体的喜悦</h2><ul>
<li><p>你可以用一个简单的标准来判断自己是否被心理时间所控制了。问自己：”我现在做的事情是否让我感到喜悦，自在和轻松呢？”如果不是，当下时刻就被时间控制了，并且生命因此被视为一个负担或一种挣扎。</p>
</li>
<li><p>如果你正在做的事情无法让你感受到喜悦，自在和轻松，这并不意味着你需要改变你正在做的事情，你需要改变的是你做事的方式。如何做事通常比做什么事更重要。试试看，如果你将注意力更多地放在你正在做的事情上，而不是放在通过做这件事所取得的结果上，你就会发现，只要关注当下时刻，你所有的不快乐和挣扎就会消失，你的生活也会充满喜悦和安逸。只要你以当下的觉知来采取行动，无论你做什么，他都会充满美德，关怀和爱————即使是一个最简单的行动。</p>
</li>
<li><p>所以请不要担心你行动的结果————仅仅关注行动本身就好了。行动的结果会自然而然的产生。这是一个非常有效的灵修方法。这在《Bhagavad Gita》中被称为业力瑜伽。它也被描述为”神圣的行动”。</p>
</li>
<li><p>当你更深的感觉是来自本体，而你也从心理需求的上瘾症中走出来时，无论你的快乐或自我感都不取决于事情的结果，因此你可以说是从恐惧中解脱了！你不会在一个无常的世界中追求永恒，因为它是一个有形有相，有得有失，有生有死的世界。你不会要求情境，状况，地点或人物让你快乐，如果他们未能达到你的要求你就痛苦。尊重每一件事，却又不在乎这一切。身体形式有生有死，但你意识到了处于形式之下的永恒的东西。当这变为你的存在状态时，你怎么会不取得成功呢？你已经成功了。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速绘制一张PCB板并生产？</title>
    <url>/2021/01/27/PCB%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="创建PCB工程项目"><a href="#创建PCB工程项目" class="headerlink" title="创建PCB工程项目"></a>创建PCB工程项目</h2><p>首先一个PCB文档应该分类准确</p>
<img src="https://z4a.net/images/2021/01/27/QQ2021012713354421be20835067724c.png" alt="QQ2021012713354421be20835067724c.png" style="zoom:50%;">

<p>然后创建一个PCB工程</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127135429.png" alt="QQ20210127135429.png" style="zoom:50%;">

<p>之后再向PCB工程中添加文件</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127135350.png" alt="QQ20210127135350.png" style="zoom:50%;">

<p>一个PCB工程中需要包括：</p>
<ul>
<li>原理图</li>
<li>PCB</li>
<li>原理图库</li>
<li>PCB封装库</li>
</ul>
<p>至于PCB库与原理图库可以直接白嫖立创的也可以直接去淘宝上买别人已经创建好的</p>
<a id="more"></a>

<h2 id="原理图的绘制"><a href="#原理图的绘制" class="headerlink" title="原理图的绘制"></a>原理图的绘制</h2><p>​    这我就不多BB了，直接绘制就好了</p>
<p>注意一下快捷键的应用就好</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127174050.png" alt="QQ20210127174050.png" style="zoom:50%;">

<p>原理图绘制好后需要对元件进行标注，这里直接全部强制标注就好了</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127135938.png" alt="QQ20210127135938.png" style="zoom: 50%;">

<p>之后为原理图中的元件添加封装</p>
<p>封装管理器：T+G 方便查看是否全部的元件都添加了封装，一般库没问题的话添加封装这方面也不会有问题</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127171446.png" alt="QQ20210127171446.png" style="zoom:50%;">

<p>之后检查无误后进行编译更新到PCB中</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127140055.png" alt="QQ20210127140055.png" style="zoom:50%;">

<p>点击验证变更</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127143840.png" alt="QQ20210127143840.png" style="zoom:50%;">

<p>右方都是绿圈说明没有问题，之后再点击执行变更后就可以导入PCB中了</p>
<h2 id="PCB的绘制"><a href="#PCB的绘制" class="headerlink" title="PCB的绘制"></a>PCB的绘制</h2><p>首先要放置一个原点</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127143458.png" alt="QQ20210127143458.png" style="zoom:50%;">

<p>然后在机械层绘制出板子的形状后，选中这些线</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127143943.png" alt="QQ20210127143943.png" style="zoom:50%;">

<p>就可以生成你需要的板子形状</p>
<p>对于需要设置安装孔的地方在机械层绘制出需要打孔的形状</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127144614.png" alt="QQ20210127144614.png" style="zoom:50%;">

<p>即可切除这部分板子</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127144726.png" alt="QQ20210127144726.png" style="zoom:50%;">

<p>接下来就是将元件部分进行布局</p>
<p>为了更好的进行PCB布局可以将窗口进行平铺，然后开启交叉选择模式在原理图中选择元件的时候PCB也会同时显示出元件的位置，更方便放置</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127171700.png" alt="QQ20210127171700.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127171646.png" alt="QQ20210127171646.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127171654.png" alt="QQ20210127171654.png" style="zoom:50%;">

<p>接下来就可以开始布局了，这是我布局完成的PCB图</p>
<p>如图</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127145010.png" alt="QQ20210127145010.png" style="zoom:50%;">

<p>点击元器件可以设置改元器件是在板子的正面还是反面</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127152129.png" alt="QQ20210127152129.png" style="zoom:50%;">

<p>为了更方便查看走线趋势，按下L+S可以唤出</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127145137.png" alt="QQ20210127145137.png" style="zoom:50%;">

<p>在这里可以隐藏或显示各个层，由于丝印层（就是黄色的那层）碍眼…我这里就先把它隐藏了</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127145406.png" alt="QQ20210127145406.png" style="zoom:50%;">

<p>之后就可以进行布线操作了</p>
<p>在布线时，由于电源线与地线是比较多的，这样会显得比较杂乱，不太看得清其他网络的走向趋势所以在这里可以先创建一个类，然后将地线与电源线添加进去，并将它们隐藏起来</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127145601.png" alt="QQ20210127145601.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127145702.png" alt="QQ20210127145702.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127145748.png" alt="QQ20210127145748.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127145801.png" alt="QQ20210127145801.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127150035.png" alt="QQ20210127150035.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127150106.png" alt="QQ20210127150106.png" style="zoom:50%;">

<p>这样的话PCB中所有的地线与电源线都被隐藏了</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127150220.png" alt="QQ20210127150220.png" style="zoom:50%;">

<p>之后就可以进行布线了，可以选择手动布线，也可以选择自动布线</p>
<p>由于板子电路比较简单，这里就选择自动布线了，但是自动布线需要进行规则设置</p>
<hr>
<h3 id="一些在PCB绘制中遇到的小问题"><a href="#一些在PCB绘制中遇到的小问题" class="headerlink" title="一些在PCB绘制中遇到的小问题"></a>一些在PCB绘制中遇到的小问题</h3><p>PCB中元件变灰了怎么办？</p>
<p>​    使用shift+c可以清除过滤器</p>
<p>PCB中如何测量元件之间的距离？</p>
<p>​    利用Ctrl+M可以测量元件之间的距离，并且利用Shift+C可以清除测量后的痕迹</p>
<p>在PCB中按Ctrl+D可以隐藏文字，覆铜等</p>
<h2 id="自动布线的规则设置"><a href="#自动布线的规则设置" class="headerlink" title="自动布线的规则设置"></a>自动布线的规则设置</h2><p>这里主要设置三个规则</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127151455.png" alt="QQ20210127151455.png" style="zoom:50%;">

<p>先设置线宽，在规则设置时，使用规则向导可以更方便的进行规则设置</p>
<p>步骤与参数如图所示</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127150449.png" alt="QQ20210127150449.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127150545.png" alt="QQ20210127150545.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127150806.png" alt="QQ20210127150806.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127150815.png" alt="QQ20210127150815.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127150824.png" alt="QQ20210127150824.png" style="zoom:50%;">



<img src="https://z4a.net/images/2021/01/27/QQ20210127150836.png" alt="QQ20210127150836.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127150844.png" alt="QQ20210127150844.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127150928.png" alt="QQ20210127150928.png" style="zoom:50%;">

<p>之后再在设计-规则一栏中找到</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127151749.png" alt="QQ20210127151749.png" style="zoom: 67%;">

<p>这是电器规则设置</p>
<p>参数如图</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127151054.png" alt="QQ20210127151054.png" style="zoom:50%;">

<p>之后设置过孔参数</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127151107.png" alt="QQ20210127151107.png" style="zoom:50%;">

<p>这样子的话，对于这张板子就差不多了</p>
<h2 id="自动走线"><a href="#自动走线" class="headerlink" title="自动走线"></a>自动走线</h2><img src="https://z4a.net/images/2021/01/27/QQ20210127152256.png" alt="QQ20210127152256.png" style="zoom:50%;">

<p>点击Route All即可自动布线</p>
<p><img src="https://z4a.net/images/2021/01/27/QQ20210127152332.png" alt="QQ20210127152332.png"></p>
<p>之后只需等待几秒钟系统就会自动走完线，显示0个Failed就说明整个板子成功布完线了</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127152417.png" alt="QQ20210127152417.png" style="zoom:50%;">

<p>如图，是不是有点那味了</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127152706.png" alt="QQ20210127152706.png" style="zoom:50%;">

<p>走完线后看看是否有些线路需要调整，差不多的话就可以进行覆铜操作了</p>
<h2 id="电路板覆铜"><a href="#电路板覆铜" class="headerlink" title="电路板覆铜"></a>电路板覆铜</h2><p>有时电路板是异形板，所以还是使用覆铜管理器来进行覆铜比较好</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127152859.png" alt="QQ20210127152859.png" style="zoom:50%;">

<p>选择板外形</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127153027.png" alt="QQ20210127153027.png" style="zoom:50%;">

<p>创建后，注意看是顶层还是底层，两层都要创建覆铜，去除死铜和网络一定要选上</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127154202.png" alt="QQ20210127154202.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127154220.png" alt="QQ20210127154220.png" style="zoom:50%;">

<p>点击应用后，铜皮就出来了如图</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127154623.png" alt="QQ20210127154623.png" style="zoom:50%;">

<p>这时还要再设置一下规则，按规定来说铜皮和走线之间的距离要大一些，所以这里设置为10mil，如图</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127154319.png" alt="QQ20210127154319.png" style="zoom:50%;">

<p>最后，再重铺下所有铜，这个板子就大致完成了</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127154954.png" alt="QQ20210127154954.png" style="zoom:50%;">

<p>最后板子就长这样</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127155035.png" alt="QQ20210127155035.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127155046.png" alt="QQ20210127155046.png" style="zoom:50%;">

<p>按下3可以查看下3D状态下的PCB板子，再按2可以切换会PCB绘制状态</p>
<p>怎么样，是不是有点那味了….</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127155057.png" alt="QQ20210127155057.png" style="zoom:50%;">

<p>这样一张PCB板子就大致完成了，之后还需要再进行下电气规则检查</p>
<h2 id="电气规则检查"><a href="#电气规则检查" class="headerlink" title="电气规则检查"></a>电气规则检查</h2><img src="https://z4a.net/images/2021/01/27/QQ20210127170841.png" alt="QQ20210127170841.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127170942.png" alt="QQ20210127170942.png" style="zoom:50%;">

<p>之后会出来一个窗口，如果板子有设计错误的话，你可以在上面看到错误信息然后进行修改</p>
<p>如图，我这张板子没有问题，那么接下来在输出Gerber文件后就可以把板子交给厂家进行生产了</p>
<p><img src="https://z4a.net/images/2021/01/27/QQ20210127171027.png" alt="QQ20210127171027.png"></p>
<h2 id="Gerber文件的输出"><a href="#Gerber文件的输出" class="headerlink" title="Gerber文件的输出"></a>Gerber文件的输出</h2><p>跟着图来进行配置即可</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127155512.png" alt="QQ20210127155512.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127155529.png" alt="QQ20210127155529.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127155608.png" alt="QQ20210127155608.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127155618.png" alt="QQ20210127155618.png" style="zoom:50%;">

<p>光圈参数保持默认就好</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127155632.png" alt="QQ20210127155632.png" style="zoom:50%;">

<p>这里注意下，在原来参数之后都加上一个0之后点确定</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127155709.png" alt="QQ20210127155709.png" style="zoom:50%;">

<p>之后在输出钻孔文件</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127155730.png" alt="QQ20210127155730.png" style="zoom:50%;">

<p>一定要勾上钻孔文件，否则之后生成不了钻孔文件</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127155802.png" alt="QQ20210127155802.png" style="zoom:50%;">

<p>这里参数保持默认就好</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127155811.png" alt="QQ20210127155811.png" style="zoom:67%;">

<p>这就是你的PCB板钻孔文件了，如图。<img src="https://z4a.net/images/2021/01/27/QQ20210127155836.png" alt="QQ20210127155836.png"></p>
<p>回到原来的PCB目录下你会发现一个Project Outputs for XXXX的文件夹，里面就是重要的PCB生产文件了</p>
<p>生成的GERBER小文件在 project Outputs for XXXX这里面找<br>小文件如下：<br>GTL顶层线路 top<br>GBL底层线路 bottom<br>GTS顶层阻焊 top solder<br>GBS底层阻焊 bottom solder<br>GTO顶层字符 top overlay<br>GBO底层字符 bottom overlay<br>DRL钻孔层<br>GKO禁止布线层（边框） keepout<br>GDD一般不用，是分孔图，用来标注和分辨孔的大小位置  </p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127161246.png" alt="QQ20210127161246.png" style="zoom:50%;">

<p>然后将这个Project Outputs for XXXX文件夹压缩成一个压缩包形式，发送给厂家就可以进行下单了</p>
<h2 id="嘉立创下单步骤"><a href="#嘉立创下单步骤" class="headerlink" title="嘉立创下单步骤"></a>嘉立创下单步骤</h2><p>由于现在嘉立创10*10之内的双层板就5元，还是比价实惠的所以就先选择在嘉立创进行打板了</p>
<p>先在嘉立创官网下载一个嘉立创下单助手吧，这样会更方便些</p>
<p><img src="https://z4a.net/images/2021/01/27/QQ20210127161619.png" alt="QQ20210127161619.png"></p>
<p>打开后找到在线下单</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127161635.png" alt="QQ20210127161635.png" style="zoom:50%;">

<img src="https://z4a.net/images/2021/01/27/QQ20210127161731.png" alt="QQ20210127161731.png" style="zoom:50%;">

<p>上传之前压缩好的Gerber文件</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127161716.png" alt="QQ20210127161716.png" style="zoom:50%;">

<p>等待几秒钟后系统会自动帮你分析好文件，之后需要填写板子的层数和需要打板的板子数量</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127161840.png" alt="QQ20210127161840.png" style="zoom:50%;">

<p>填写好之后点击下一步继续</p>
<p>PCB工艺如图</p>
<p>阻焊颜色可以随便选，不过绿色的生产要快些，板子厚度2.0与0.4都需要加钱，一般情况下就选1.2或者1.6就好，阻焊选择过孔盖油，焊盘喷漆的话选择选择有铅喷锡就好，沉金需要加钱，其余默认</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127161931.png" alt="QQ20210127161931.png" style="zoom:50%;">

<p>SMT贴片的话看个人情况，如果需要SMT贴片的话还需要生成贴片文件，这里先选择不需要</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127161942.png" alt="QQ20210127161942.png" style="zoom:50%;">

<p>这里保持默认就好</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127161957.png" alt="QQ20210127161957.png" style="zoom:50%;">

<p>看个人情况选择是否需要钢网，这里先选择不需要了</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127162018.png" alt="QQ20210127162018.png" style="zoom:50%;">

<p>发票同样看个人情况</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127162044.png" alt="QQ20210127162044.png" style="zoom:50%;">

<p>再填好地址与送货选项，最后确认无误后付钱就好了</p>
<img src="https://z4a.net/images/2021/01/27/QQ20210127162137.png" alt="QQ20210127162137.png" style="zoom:50%;">

<hr>
<p>至此这样一张PCB板制作就完成了</p>
<p>一般2~3天板子就到手了</p>
<p>芜湖<del>~</del></p>
]]></content>
      <tags>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>通过CUBEMX来创建STM32工程并点亮一个LED灯</title>
    <url>/2021/01/29/%E4%BD%BF%E7%94%A8CUBEMX%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E5%B9%B6%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AALED/</url>
    <content><![CDATA[<p>CubeMX可以在ST的官方进行下载，下载最新版本的就好</p>
<h2 id="HAL固件库文件的放置"><a href="#HAL固件库文件的放置" class="headerlink" title="HAL固件库文件的放置"></a>HAL固件库文件的放置</h2><p>下载好CubeMX之后将他打开，它的界面是这样的</p>
<img src="https://z4a.net/images/2021/01/29/QQ20210129150802.png" alt="QQ20210129150802.png" style="zoom:67%;">

<p>点击Help后可以设置下载的固件包文件的位置，最好自己添加一个新的文件夹来专门存储，不要放置在C盘</p>
<a id="more"></a>

<p><img src="https://z4a.net/images/2021/01/29/QQ20210129151218.png" alt="QQ20210129151218.png"></p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129151233.png" alt="QQ20210129151233.png"></p>
<h2 id="创建一个新的工程"><a href="#创建一个新的工程" class="headerlink" title="创建一个新的工程"></a>创建一个新的工程</h2><p>这里选择第一个就好</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129151916.png" alt="QQ20210129151916.png"></p>
<img src="https://z4a.net/images/2021/01/29/QQ20210129151351.png" alt="QQ20210129151351.png" style="zoom:50%;">

<p>选择好芯片封装之后双击芯片封装就可以创建一个新的工程了</p>
<p>如图，这样的话就可以正式的来配置STM32了</p>
<img src="https://z4a.net/images/2021/01/29/QQ20210129151431.png" alt="QQ20210129151431.png" style="zoom:50%;">

<h2 id="配置STM32的GPIO并将LED灯点亮"><a href="#配置STM32的GPIO并将LED灯点亮" class="headerlink" title="配置STM32的GPIO并将LED灯点亮"></a>配置STM32的GPIO并将LED灯点亮</h2><p>我这里用的是野火的指南者开发板，用的是PB5,PB0,PB1来控制LED，所以初始化GPIO的时候应该初始化这几个管脚</p>
<img src="https://z4a.net/images/2021/01/29/QQ20210129152644.png" alt="QQ20210129152644.png" style="zoom:50%;">

<p>在右侧选择相应的管脚号，可以看到这个管脚具有的功能，这里要点亮LED灯，所以应该选择GPIO_Output功能</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129154240.png" alt="QQ20210129154240.png"></p>
<p>选择好管脚之后就可以看到GPIO栏中出现了这几个选项，可以根据用户的需要来进行配置</p>
<p>由于开发板上LED是低电平点亮，所以这里默认不用修改就好</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129154436.png" alt="QQ20210129154436.png"></p>
<p>这里要注意的是，系统配置那里Debug要选则成串行模式，否则程序只可以下载一次</p>
<img src="https://z4a.net/images/2021/01/29/QQ20210129155120.png" alt="QQ20210129155120.png" style="zoom: 67%;">

<p>系统时钟的话就先默认就可以</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129155324.png" alt="QQ20210129155324.png"></p>
<p>工程创建如图所示</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129160025.png" alt="QQ20210129160025.png"></p>
<p>代码生成配置如图所示，一般情况下就是这样配置的</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129160659.png" alt="QQ20210129160659.png"></p>
<p>优先级设置如图所示</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129163234.png" alt="QQ20210129163234.png"></p>
<p>点击生成代码即可</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129163807.png" alt="QQ20210129163807.png"></p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129163853.png" alt="QQ20210129163853.png"></p>
<p>可以看到代码以及为我们自动生成了，这比固件库函数编程的要方便许多</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129163927.png" alt="QQ20210129163927.png"></p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129164722.png" alt="QQ20210129164722.png"></p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129164733.png" alt="QQ20210129164733.png"></p>
<p>下载到板子后,可以看到LED灯成功亮起</p>
<img src="https://z4a.net/images/2021/01/29/IMG_20210129_165105.jpg" alt="IMG_20210129_165105.jpg" style="zoom: 25%;">

<p>也可以将代码修改,将LED转换为流水灯的形式</p>
<p>这里HAL库中的延迟函数是HAL_Delay();是1ms延时</p>
<p><img src="https://z4a.net/images/2021/01/29/QQ20210129165738.png" alt="QQ20210129165738.png"></p>
<img src="https://z4a.net/images/2021/01/29/VID_20210129_165721.gif" alt="VID_20210129_165721.gif" style="zoom:25%;">

<hr>
<p>这样一个HAL库工程就创建完成了</p>
]]></content>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>通过CUBEMX来配置TIM定时器中断</title>
    <url>/2021/02/07/%E4%BD%BF%E7%94%A8CubeMX%E6%9D%A5%E9%85%8D%E7%BD%AETIM%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h1 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h1><p>首先是时钟的配置，这里选择外部晶振</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207005753.png" alt="QQ20210207005753.png"></p>
<p>然后是系统，要选择Debug形式，然后时钟源这里选择系统的滴答定时器</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207005800.png" alt="QQ20210207005800.png"></p>
<a id="more"></a>

<p>之后是TIM定时器的时钟源选择，这里就先选择内部时钟源，通道的话不用打开</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207005817.png" alt="QQ20210207005817.png"></p>
<p>之后配置分频系数，计数模式与计时周期.这里的一次计时周期就是1ms</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207005841.png" alt="QQ20210207005841.png"></p>
<p>为TIM2配置中断是否开启以及它的优先级</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207005854.png" alt="QQ20210207005854.png"></p>
<p>在内核配置中可以配置中断优先级的分组，这里就选择第四组了，在这里也可以看到全部的中断源配置</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207005909.png" alt="QQ20210207005909.png"></p>
<p>之后是时钟树的配置，需要注意的是外部时钟源需要与板子实际使用的一致，其他的如果没有需求就不用管了，然后HCLK处我习惯100MHz直接傻瓜式配置，系统会自动帮你计算</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207005947.png" alt="QQ20210207005947.png"></p>
<p>之后配置好相关文件路径就可以生成代码了</p>
<h1 id="一些相关的函数"><a href="#一些相关的函数" class="headerlink" title="一些相关的函数"></a>一些相关的函数</h1><p>一进入主函数，首先需要用</p>
<pre class=" language-c"><code class="language-c">HAL_StatusTypeDef <span class="token function">HAL_TIM_Base_Start_IT</span><span class="token punctuation">(</span>TIM_HandleTypeDef <span class="token operator">*</span>htim<span class="token punctuation">)</span></code></pre>
<p>来开启TIM2的中断。参数就是中断源的句柄，可以在tim.c文件中看到</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207010946.png" alt="QQ20210207010946.png"></p>
<p>之后在stm32f4xx_it.c文件下会看到自动生成了TIM2的中断处理函数</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207011003.png" alt="QQ20210207011003.png"></p>
<p>需要注意的是在HAL库中，每进行完一个中断，并不会立刻退出，而是会进入到中断回调函数中</p>
<p>所以我们需要在tim.c文件下自己创建一个TIM2相关的中断回调函数 </p>
<p>在中断回调函数中就可以添加用户自己相应的代码了</p>
<p><img src="https://z4a.net/images/2021/02/07/QQ20210207011015.png" alt="QQ20210207011015.png"></p>
]]></content>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>利用CubeMX初始化TIM与串口并测试FreeRTOS的中断管理函数</title>
    <url>/2021/02/09/%E5%88%A9%E7%94%A8CubeMX%E5%88%9D%E5%A7%8B%E5%8C%96TIM%E4%B8%8E%E4%B8%B2%E5%8F%A3%E5%B9%B6%E6%B5%8B%E8%AF%95FreeRTOS%E7%9A%84%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>创建两个任务start_task()与interrupt_task(), 这两个任务的功能如下：</p>
<p>start_task()：创建另一个任务</p>
<p>interrupt_task()：中断测试任务，任务中会调用FreeRTOS的关中断函数portDISABLE_INTERRUPTS()来将中断关闭一段时间</p>
<h1 id="CubeMX的配置"><a href="#CubeMX的配置" class="headerlink" title="CubeMX的配置"></a>CubeMX的配置</h1><h2 id="首先是FreeRTOS的配置"><a href="#首先是FreeRTOS的配置" class="headerlink" title="首先是FreeRTOS的配置"></a>首先是FreeRTOS的配置</h2><p>箭头处是FreeRTOS所能控制的最大和最低的优先级，高于或者低于这两个优先级的中断无法被FreeRTOS的中断控制函数控制</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209162857.png" alt="QQ20210209162857.png"></p>
<p>创建好两个任务</p>
<a id="more"></a>

<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163003.png" alt="QQ20210209163003.png"></p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163010.png" alt="QQ20210209163010.png"></p>
<p>这样一来FreeRTOS基本配置完成</p>
<h2 id="STM32外设的配置"><a href="#STM32外设的配置" class="headerlink" title="STM32外设的配置"></a>STM32外设的配置</h2><p>这里先确定好几个LED用作测设</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209162421.png" alt="QQ20210209162421.png"></p>
<p>时钟源的配置</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163550.png" alt="QQ20210209163550.png"></p>
<p>这一要把Debug的模式改一下否则程序只能下载一次，然后我这里的时钟源选择是TIM1</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163602.png" alt="QQ20210209163602.png"></p>
<p>初始化TIM2和TIM3，二者我都是初始化为1ms产生一次中断计数，时钟源都要选择为内部时钟源，记得要开启自动重装载，向上计数</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163654.png" alt="QQ20210209163654.png"></p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163710.png" alt="QQ20210209163710.png"></p>
<p>这里要把TIM2和TIM3的中断都使能</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163702.png" alt="QQ20210209163702.png"></p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163715.png" alt="QQ20210209163715.png"></p>
<p>在这里我把中断优先级分组设成了第四组。为了要测试FreeRTOS的中断控制函数，我就把TIM2的抢占优先级设置成了2，为了不影响串口的收发我把它的抢占优先级设置为了3。</p>
<p>需要注意的是，在FreeRTOS所控制的优先级之外的中断中是不可以使用FreeRTOS内置的API函数的，就算是带有IRQ后缀的函数也不可以，所以这里可以把是否使用FreeRTOS函数的选项给取消了</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163750.png" alt="QQ20210209163750.png"></p>
<p>串口模式选择收发，并且使能它的中断</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163816.png" alt="QQ20210209163816.png"></p>
<p>这里就是时钟树的配置，输入频率要和自己单片机实际使用的晶振一样，然后后面的HCLK频率配置只需要写好系统会自动配置</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163856.png" alt="QQ20210209163856.png"></p>
<p>这里注意下函数是否为静态的，然后就可以生成代码了</p>
<p><img src="https://z4a.net/images/2021/02/09/QQ20210209163914.png" alt="QQ20210209163914.png"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="定时中断"><a href="#定时中断" class="headerlink" title="定时中断"></a>定时中断</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 中断回调函数 1s 一次中断 输出测试语句 并且LED闪烁 */</span>
<span class="token keyword">void</span> <span class="token function">HAL_TIM_PeriodElapsedCallback</span><span class="token punctuation">(</span>TIM_HandleTypeDef <span class="token operator">*</span>htim<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* USER CODE BEGIN Callback 0 */</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> time2<span class="token punctuation">,</span>time3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">/* USER CODE END Callback 0 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>htim<span class="token operator">-></span>Instance <span class="token operator">==</span> TIM1<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">HAL_IncTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* USER CODE BEGIN Callback 1 */</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>htim <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>htim2<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        time2<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>time2 <span class="token operator">==</span> <span class="token number">1000</span><span class="token punctuation">)</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            time2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TIM2_OK\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>LED_B_GPIO_Port<span class="token punctuation">,</span>LED_B_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>htim <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        time3<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>time3 <span class="token operator">==</span> <span class="token number">1000</span><span class="token punctuation">)</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            time3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TIM3_OK\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>LED_R_GPIO_Port<span class="token punctuation">,</span>LED_R_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    
  <span class="token comment" spellcheck="true">/* USER CODE END Callback 1 */</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h1 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h1><p>这里用的是正点原子的延迟函数,记录一下方便以后移植使用</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"delay.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"cmsis_os.h"</span></span>

<span class="token keyword">static</span> u32 fac_us<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> u16 fac_ms<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">xPortSysTickHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/* 参数为倍频后的HCLK 我这里是100MHz */</span>
<span class="token keyword">void</span> <span class="token function">delay_init</span><span class="token punctuation">(</span>u8 SYSCLK<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    u32 reload<span class="token punctuation">;</span>
      <span class="token function">HAL_SYSTICK_CLKSourceConfig</span><span class="token punctuation">(</span>SYSTICK_CLKSOURCE_HCLK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//SysTick频率为HCLK</span>
    fac_us<span class="token operator">=</span>SYSCLK<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//不论是否使用OS,fac_us都需要使用</span>
    reload<span class="token operator">=</span>SYSCLK<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//每秒钟的计数次数 单位为K       </span>
    reload<span class="token operator">*</span><span class="token operator">=</span><span class="token number">1000000</span><span class="token operator">/</span>configTICK_RATE_HZ<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根据configTICK_RATE_HZ设定溢出时间</span>
                                            <span class="token comment" spellcheck="true">//reload为24位寄存器,最大值:16777216,在180M下,约合0.745s左右    </span>
    fac_ms<span class="token operator">=</span><span class="token number">1000</span><span class="token operator">/</span>configTICK_RATE_HZ<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//代表OS可以延时的最少单位        </span>
      SysTick<span class="token operator">-></span>CTRL<span class="token operator">|</span><span class="token operator">=</span>SysTick_CTRL_TICKINT_Msk<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启SYSTICK中断</span>
    SysTick<span class="token operator">-></span>LOAD<span class="token operator">=</span>reload<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//每1/configTICK_RATE_HZ断一次    </span>
    SysTick<span class="token operator">-></span>CTRL<span class="token operator">|</span><span class="token operator">=</span>SysTick_CTRL_ENABLE_Msk<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//开启SYSTICK</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">delay_us</span><span class="token punctuation">(</span>u32 nus<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        
    u32 ticks<span class="token punctuation">;</span>
    u32 told<span class="token punctuation">,</span>tnow<span class="token punctuation">,</span>tcnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    u32 reload<span class="token operator">=</span>SysTick<span class="token operator">-></span>LOAD<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//LOAD的值             </span>
    ticks<span class="token operator">=</span>nus<span class="token operator">*</span>fac_us<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//需要的节拍数 </span>
    told<span class="token operator">=</span>SysTick<span class="token operator">-></span>VAL<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//刚进入时的计数器值</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        tnow<span class="token operator">=</span>SysTick<span class="token operator">-></span>VAL<span class="token punctuation">;</span>    
        <span class="token keyword">if</span><span class="token punctuation">(</span>tnow<span class="token operator">!=</span>told<span class="token punctuation">)</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        
            <span class="token keyword">if</span><span class="token punctuation">(</span>tnow<span class="token operator">&lt;</span>told<span class="token punctuation">)</span>tcnt<span class="token operator">+</span><span class="token operator">=</span>told<span class="token operator">-</span>tnow<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这里注意一下SYSTICK是一个递减的计数器就可以了.</span>
            <span class="token keyword">else</span> tcnt<span class="token operator">+</span><span class="token operator">=</span>reload<span class="token operator">-</span>tnow<span class="token operator">+</span>told<span class="token punctuation">;</span>        
            told<span class="token operator">=</span>tnow<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tcnt<span class="token operator">>=</span>ticks<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//时间超过/等于要延迟的时间,则退出.</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                                        
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">delay_ms</span><span class="token punctuation">(</span>u32 nms<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">xTaskGetSchedulerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>taskSCHEDULER_NOT_STARTED<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//系统已经运行</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        
        <span class="token keyword">if</span><span class="token punctuation">(</span>nms<span class="token operator">>=</span>fac_ms<span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">//延时的时间大于OS的最少时间周期 </span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> 
               <span class="token function">vTaskDelay</span><span class="token punctuation">(</span>nms<span class="token operator">/</span>fac_ms<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//FreeRTOS延时</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        nms<span class="token operator">%</span><span class="token operator">=</span>fac_ms<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//OS已经无法提供这么小的延时了,采用普通方式延时    </span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token function">delay_us</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span><span class="token punctuation">(</span>nms<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//普通方式延时</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/* 不会引起任务调度的延迟函数 */</span>
<span class="token keyword">void</span> <span class="token function">delay_xms</span><span class="token punctuation">(</span>u32 nms<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    u32 i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nms<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">delay_us</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h1 id="串口收发函数"><a href="#串口收发函数" class="headerlink" title="串口收发函数"></a>串口收发函数</h1><p>在usart.c文件中添加，这样就可以使用printf()函数了</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> FILE <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ch<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  uint8_t ch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">HAL_UART_Receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ch<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>注意在main.h文件中</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span>    </span></code></pre>
<p>在main.c文件中定义两个数组</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 定义两个数组 */</span>
u8 aRxBuffer<span class="token punctuation">[</span>RXBUFFERSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//HAL库使用的串口接收缓冲</span>
u8 USART_RX_BUF<span class="token punctuation">[</span>USART_REC_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//接收缓冲,最大USART_REC_LEN个字节.</span></code></pre>
<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>huart<span class="token operator">-></span>Instance<span class="token operator">==</span>USART1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果是串口1</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span>aRxBuffer<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 接收到数据马上使用串口1发送出去</span>
        <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span>aRxBuffer<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 重新使能串口1接收中断</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>最后使能这几个用到的中断</p>
<pre class=" language-c"><code class="language-c"><span class="token function">HAL_TIM_Base_Start_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">HAL_TIM_Base_Start_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>aRxBuffer<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h1 id="任务函数"><a href="#任务函数" class="headerlink" title="任务函数"></a>任务函数</h1><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">StartDefaultTask</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> argument<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* USER CODE BEGIN StartDefaultTask */</span>

    <span class="token function">taskENTER_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 进入临界区 */</span>

  <span class="token comment" spellcheck="true">/* definition and creation of interrupt_task */</span>
  <span class="token function">osThreadDef</span><span class="token punctuation">(</span>interrupt_task<span class="token punctuation">,</span> Start_interrupt_task<span class="token punctuation">,</span> osPriorityNormal<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  interrupt_taskHandle <span class="token operator">=</span> <span class="token function">osThreadCreate</span><span class="token punctuation">(</span><span class="token function">osThread</span><span class="token punctuation">(</span>interrupt_task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">vTaskDelete</span><span class="token punctuation">(</span>Start_TaskHandle<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 删除开始任务 */</span> 

    <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 退出临界区 */</span>

  <span class="token comment" spellcheck="true">/* USER CODE END StartDefaultTask */</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Start_interrupt_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> argument<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* USER CODE BEGIN Start_interrupt_task */</span>
    <span class="token keyword">static</span> u32 num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        num<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            num <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"中断关闭.......\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">portDISABLE_INTERRUPTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">delay_xms</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"打开中断.......\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">portENABLE_INTERRUPTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>LED_G_GPIO_Port<span class="token punctuation">,</span>LED_G_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">/* USER CODE END Start_interrupt_task */</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h1 id="几个需要注意的"><a href="#几个需要注意的" class="headerlink" title="几个需要注意的"></a>几个需要注意的</h1><ol>
<li>CubeMX生成的代码最好不要乱修改，用户自己的代码最好写在CubeMX规定的代码区域</li>
<li>某些需要在多个文件中用到的变量或者数组，可以在main.c文件中定义，然后在main.h文件中extern</li>
<li>中断处理函数集中在stm32f4xx_it.c这个文件中，中断处理函数一般集中在main.c文件下，这样方便管理</li>
</ol>
]]></content>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS队列与队列函数</title>
    <url>/2021/02/17/FreeRTOS%E9%98%9F%E5%88%97%E4%B8%8E%E9%98%9F%E5%88%97%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h1><p>​    在实际的应用中，常会遇到一个任务或者中断服务需要和另外一个任务进行“沟通交流”。这个“沟通交流”的过程其实就是消息传递的过程。</p>
<p>​    在没有操作系统的时候两个应用程序进行消息传递一般使用全局变量的方式，但是如果在使用操作系统的应用中用全局变量来传递消息就会涉及到“资源管理”的问题。FreeRTOS对此提供了一个叫做“队列”的机制来完成任务与任务，任务与中断之间的消息传递。</p>
<p>​    队列可以在任务与任务，任务与中断之间传递消息，队列中可以存储有限的，大小固定的数据项目。任务与任务，任务与中断之间的要交流的数据保存在队列中，叫队列项目。</p>
<p>​    队列所能保存的最大数据项目数量叫做队列的长度，创建队列的时候会指定数据项目的大小和队列的长度。由于队列是用来传递消息的，所以又被称为消息队列。同时FreeRTOS中的信号量也是依据消息队列实现的。</p>
<hr>
<a id="more"></a>

<h2 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1. 数据存储"></a>1. 数据存储</h2><p>​    通常队列采用先进先出(FIFO)的存储缓冲的存储缓冲机制，也就是往队列发送数据的时候（也叫入队）永远都是发送到队列的尾部，而从队列提取数据的时候（也叫出队）是从队列的头部提取的。但是也可以使用LIFO的存储缓冲，也就是后入先出，FreeRTOS中的队列也提供了这种机制。</p>
<p>​    数据发送到队列中会导致数据拷贝，也就是将要发送的数据拷贝到队列中，这意味着在队列中存储的是数据的原始值，而不是原数据的引用（即只传递数据的指针），这种数据发送形式就是值传递。</p>
<p>​    FreeRTOS这种采用值传递的方式必然会浪费一些时间，但是这样一来就算是局部变量也可以进行数据的传递了，并且这种值传递的方式也可以将指针传入，这样一来即使要传递的消息数据太大也不用担心了。    </p>
<h2 id="2-多任务访问"><a href="#2-多任务访问" class="headerlink" title="2. 多任务访问"></a>2. 多任务访问</h2><p>​    队列不是属于某个特定任务的，任何任务都可以向队列中发送消息，或者从队列中提取消息</p>
<h2 id="3-出队阻塞"><a href="#3-出队阻塞" class="headerlink" title="3. 出队阻塞"></a>3. 出队阻塞</h2><p>​    当任务尝试从一个队列中读取消息的时候可以指定一个阻塞时间，这个阻塞时间就是当任务从队列中读取消息无效的时候任务阻塞的时间。</p>
<p>​    出队就是从队列中读取消息，出队阻塞是针对从队列中读取消息的任务而言的。比如A任务用于处理串口接收到的数据，串口接收到数据以后就会放到队列Q中，任务A从队列Q中读取数据。但如果此时队列Q是空的，说明还没有数据，任务A这时候来读取的话肯定是获取不到任何东西，那该怎么办？任务A现在有三种选择：</p>
<ol>
<li><p>二话不说扭头就走</p>
</li>
<li><p>要不再等等，说不定一会就有数据传递过来了</p>
</li>
<li><p>死等，直到等到数据传过来为止</p>
</li>
</ol>
<p>​    选择哪一个就是由这个阻塞时间来决定的，这个阻塞时间单位是<strong>时钟节拍数</strong>。</p>
<ul>
<li>阻塞时间为0的话就是不阻塞没有数据的话马上返回来继续进行接下来的代码操作</li>
<li>如果阻塞时间为0 ~ portMAX_DELAY，当任务没有从队列中获取到消息的话就进入<strong>阻塞态</strong>，当阻塞时间到了以后还没有接收到数据的话就退出阻塞态，返回任务接着运行下面的代码，如果在阻塞时间之内接收到了数据就立即返回，执行任务中下面的代码</li>
<li>如果阻塞时间为portMAX_DELAY的话，任务就会一直处于阻塞态等待，知道接收到数据为止</li>
</ul>
<h2 id="4-入队阻塞"><a href="#4-入队阻塞" class="headerlink" title="4. 入队阻塞"></a>4. 入队阻塞</h2><p>​    入队说的是向队列中发送消息，将消息加入到队列中。和出队阻塞一样，当一个任务向队列发送消息的话也可以设置阻塞时间。比如任务B向消息队列Q发送消息，但是此时队列Q是满的，那肯定是发送失败的。此时任务B就会遇到和上面任务A一样的问题，二者处理方式类似，只不过一个是向队列Q读取消息，一个是向队列Q发送消息。</p>
<p>#</p>
<h2 id="5-队列操作过程图示"><a href="#5-队列操作过程图示" class="headerlink" title="5. 队列操作过程图示"></a>5. 队列操作过程图示</h2><p>图13.1.1中任务A要向任务B发送消息，这个消息是X变量的值。首先创建一个队列，并指定队列的长度和每条消息的长度。这里创建了一个长度为4的队列，因要要传递的是X值，而X是个int类型的变量，所以每条消息的长度就是int类型的长度，在STM32中就是4个字节，即每条消息是四个字节</p>
<p><img src="https://z4a.net/images/2021/02/12/QQ20210212165830.png" alt="QQ20210212165830.png"></p>
<p>图13.1.2中任务A的变量X值为10，将这个值发送到消息队列中。此时队列剩余长度就是3了。前面说了向队列中发送消息是采用拷贝的方式，所以一旦消息发送完成变量X就可以再次被使用，赋其他的值</p>
<p><img src="https://z4a.net/images/2021/02/12/QQ20210212165840.png" alt="QQ20210212165840.png"></p>
<p>图13.1.3中任务A又向队列发送了一个消息，即新的X的值，这里是20。此时队列的长度为2</p>
<p><img src="https://z4a.net/images/2021/02/12/QQ20210212165849.png" alt="QQ20210212165849.png"></p>
<p>图13.1.4中任务B从队列中读取消息，并将读到的消息值赋值给y,这样y就等于10了。任务B从队列读取消息完成之后可以选择清除或者不清除掉这个消息。当选择清除这个消息的话其他任务或中断就不能获取这个消息了，而且队列剩余大小就会加1，变成3.如果不清除的话其他任务或中断也可以获取这个消息，而且队列的剩余大小依旧是2。</p>
<p><img src="https://z4a.net/images/2021/02/12/QQ20210212165857.png" alt="QQ20210212165857.png"></p>
<hr>
<h1 id="相关的队列操作函数"><a href="#相关的队列操作函数" class="headerlink" title="相关的队列操作函数"></a>相关的队列操作函数</h1><h2 id="入队函数"><a href="#入队函数" class="headerlink" title="入队函数"></a>入队函数</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 任务级入队函数 */</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token comment" spellcheck="true">/* 发送消息到队列尾部（后向入队），这两个函数是一样的 */</span>
<span class="token function">xQueueSend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">xQueueSendToBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token comment" spellcheck="true">/* 发送消息到队列头 */</span>    
<span class="token function">xQueueSendToFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">/* 发送消息到队列，带覆写功能，当队列满了之后自动覆盖掉旧的消息 */</span>      
<span class="token function">xQueueOverwrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token comment" spellcheck="true">/* 中断级入队函数 */</span>
<span class="token function">xQueueSendFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">xQueueSendToBackFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">xQueueSendToFrontFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">xQueueOverwriteFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    </code></pre>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xQueueSend</span><span class="token punctuation">(</span> QueueHandle_t xQueue<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span> TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span>
BaseType_t <span class="token function">xQueueSendToBack</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span> TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span>
BaseType_t <span class="token function">xQueueSendToToFront</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvItemToQueue<span class="token punctuation">,</span> TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>参数</strong></p>
<ul>
<li>xQueue: 队列句柄,指要向那个队列发送数据</li>
<li>pvItemToQueue: 指向要发送的消息，发送时候会将这个消息自动拷贝到队列中</li>
<li>xTicksToWait: 阻塞时间</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>pdPASS：向队列发送消息成功 ！</li>
<li>errQUEUE_FULL: 队列已经满了，消息发送失败。</li>
</ul>
<hr>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xQueueOverwrite</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvItemToQueue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><em>此函数也是用于向队列发送数据的，当队列满了之后会覆盖掉旧的数据，不管这个旧的数据有没有被其他任务或者中断取走。该函数常用于向那些长度为1的队列发送消息。</em></p>
<p><strong>参数</strong></p>
<ul>
<li>xQueue：队列句柄,指要向那个队列发送数据</li>
<li>pvItemToQueue: 指向要发送的消息，发送时候会将这个消息自动拷贝到队列中</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>pdPASS：向队列发送消息成功 ！(因为这个函数是强行覆写，所以一定是成功的)</li>
</ul>
<hr>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xQueueSendFromISR</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span> 
                             <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span> 
                             BaseType_t <span class="token operator">*</span> pxHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>
BaseType_t <span class="token function">xQueueSendToBackFromISR</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span> 
                                   <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span> 
                                   BaseType_t <span class="token operator">*</span> pxHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>
BaseType_t <span class="token function">xQueueSendToFrontFromISR</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span> 
                                    <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span> 
                                    BaseType_t <span class="token operator">*</span> pxHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>参数</strong></p>
<ul>
<li>xQueue：队列句柄,指要向那个队列发送数据</li>
<li>pvItemToQueue: 指向要发送的消息，发送时候会将这个消息自动拷贝到队列中</li>
<li>pxHigherPriorityTaskWoken：标记退出此函数以后是否进行任务切换，这个变量的值由这三个函数来设置的，用户不进行设置，用户只需要提供一个变量来保存这个值就好了。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li><p>pdPASS：向队列发送消息成功！</p>
</li>
<li><p>errQUEUE_FULL: 队列已经满了，消息发送失败。</p>
<p><em>这些函数都没有设置阻塞时间。原因就是这些函数是在中断中调用的，并不是在任务中，所以也就没有了阻塞一说了</em></p>
</li>
</ul>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xQueueOverwriteFromISR</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span> 
                                  <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvItemToQueue<span class="token punctuation">,</span>
                                  BaseType_t <span class="token operator">*</span> pxHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>此函数的返回值与上面三个相同</p>
<h2 id="队列读取函数"><a href="#队列读取函数" class="headerlink" title="队列读取函数"></a>队列读取函数</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 任务级出队函数 */</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token comment" spellcheck="true">/* 从队列中读取队列项并且删除 */</span>    
<span class="token function">xQueueReceive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">/* 从队列中读取队列项但不删除 */</span>    
<span class="token function">xQueuePeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token comment" spellcheck="true">/* 中断级出队函数 */</span>  
<span class="token function">xQueueReceiveFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
<span class="token function">xQueuePeekFromISR</span> <span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xQueueReceive</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span> 
                         <span class="token keyword">void</span> <span class="token operator">*</span> pvBuffer<span class="token punctuation">,</span> 
                         TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><em>此函数在读取消息的时候采用拷贝的方式，所以用户需要提供一个数组或缓冲区来保存读取到的数据，所读取数据的长度是创建队列的时候所设定的每个队列的长度</em></p>
<p><strong>参数</strong></p>
<ul>
<li>xQueue：队列句柄，指要读取哪个队列的数据</li>
<li>pvBuffer：保存数据的缓冲区</li>
<li>xTicksToWait：阻塞时间</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>pdTRUE：从队列中读取数据成功</li>
<li>pdFALSE:从队列中读取数据失败</li>
</ul>
<hr>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xQueuePeek</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span>
                      <span class="token keyword">void</span> <span class="token operator">*</span> pvBuffer<span class="token punctuation">,</span> 
                      TickType_t xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>参数</strong></p>
<ul>
<li>xQueue：队列句柄，指要读取哪个队列的数据</li>
<li>pvBuffer：保存数据的缓冲区</li>
<li>xTicksToWait：阻塞时间</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>pdTRUE：从队列中读取数据成功</li>
<li>pdFALSE:从队列中读取数据失败</li>
</ul>
<p><strong>读取队列函数的中断模式同理</strong></p>
<h1 id="相关函数使用注意事项"><a href="#相关函数使用注意事项" class="headerlink" title="相关函数使用注意事项"></a>相关函数使用注意事项</h1><ol>
<li>关于消息的发送与接收是以队列的1个长度为单位的，需要搬运数组等类型数据时需要多次循环使用消息队列收发函数</li>
<li>如果需要在搬运串口接收到的数据的话，串口中断优先级需要在FreeRTOS设置的优先级之内，否则无法使用中断类型函数，并且还要注意任务切换</li>
<li>队列的长度单位需要注意，需要与要搬运的数据长度一致</li>
</ol>
]]></content>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS信号量与信号量函数</title>
    <url>/2021/02/19/FreeRTOS%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h1><p>​    信号量是操作系统中重要的一部分，信号量一般用来进行资源管理和任务同步，FreeRTOS中信号量又分为二值信号量，计数型信号量，互斥信号量和递归互斥信号量。不同信号量其应用场景不同，但有些应用场景是可以互换着使用的。</p>
<p>​    信号量的重要作用其中就有任务的同步，用于任务与任务之间的同步，用于中断与任务之间的同步。在执行中断服务函数的时候可以通过向任务发送信号量来通知它所期待的事情发生了，当退出中断服务函数以后在任务调度器的调度下同步的任务回去执行。</p>
<p>​    在编写中断服务函数的时候一定是要快进快出的，中断服务函数中一般都不能放入太多的代码，否则就会影响系统的实时性。在裸机编写代码的时候一般都只是在中断服务函数中打一个标记，然后在其他的地方根据标记的值来进行具体的处理过程。而这些在RTOS中就可以借助信号量来进行实现。</p>
<p>​    当中断发生的时候就释放信号量，但在中断服务函数中不做具体的处理。具体的处理过程做成一个任务，这个任务会获取信号量，如果获取到信号量就说明中断发生了，需要进行相应的处理，这样做的好处就是中断的时间会非常短。当然任务与任务之间也可以通过信号量来进行同步。</p>
<a id="more"></a>

<h1 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h1><p>​    二值信号量通常用于互斥访问或同步。互斥信号量拥有优先级继承机制，二值信号量没有优先级继承。因此二值信号量更适合用于同步任务与中断或者任务与任务，而互斥信号量更适合用于简单的互斥访问。</p>
<p>​    和队列一样，信号量API函数允许设置一个阻塞时间，阻塞时间是当任务获取信号量的时候由于信号量无效从而导致任务进入阻塞态的最大时钟节拍数。如果多个任务同时阻塞在同一个信号量上的话那么哪个任务的优先级高，哪个任务就优先获得信号量，这样当信号量有效的时候高优先级的任务就会解除阻塞状态。</p>
<p>​    二值信号量其实就是只有一个队列项的队列，这个特殊的队列要么是满的，要么是空的，所以其被称之为二值信号量。只需要知道这个队列项是空的还是满的，就可以利用这个机制来完成任务与中断之间的同步。</p>
<p>​    在实际应用中通常会使用一个任务来处理MCU的某个外设，比如在网络应用中，一般最简单的方法就是使用一个任务去轮询的查询MCU的ETH外设是否有数据，当有数据的时候就处理这个网络数据。这样使用轮询的方式是很浪费CPU资源的，而且也阻止了其他任务的运行。最理想的方法就是当没有网络数据的时候该任务进入阻塞态，把CPU让给其他任务，当有数据的时候采取执行。</p>
<p>​    现在通过信号量就可完成这样的目标任务通过获取二值信号量来判断是否有网络数据，没有的话就进入阻塞状态，当网络中断发生了，就会在中断服务函数中释放信号量来通知任务可以去处理数据了。</p>
<h2 id="获取二值信号量的过程"><a href="#获取二值信号量的过程" class="headerlink" title="获取二值信号量的过程"></a>获取二值信号量的过程</h2><p><img src="https://z4a.net/images/2021/02/18/QQ20210218003010.png" alt="QQ20210218003010.png"></p>
<p>图14.2.1.1中任务Task通过函数xSemaphoreTake()获取信号量，但是此时二值信号量无效，所以任务Task进入阻塞状态</p>
<p><img src="https://z4a.net/images/2021/02/18/QQ20210218003037.png" alt="QQ20210218003037.png"></p>
<p>此时中断发生了，在中断服务函数中通过函数xSemaphoreGiveFromISR()释放信号量，因此信号量变为有效</p>
<p><img src="https://z4a.net/images/2021/02/18/QQ20210218003047.png" alt="QQ20210218003047.png"></p>
<p>由于信号量已经有效了，所以任务Task获取信号量成功，任务从阻塞态解除，开始执行相关的处理过程</p>
<ol start="4">
<li><p>任务再次进入阻塞态</p>
<p>由于任务函数一般都是一个大循环，所以在任务做完相关的处理之后就会再次调用函数xSemaphoreTake()获取信号量。在执行完第三步以后二值信号量就已经变为无效的了，所以任务将再次进入阻塞状态，和以第一步一样直到中断再次发生并调用函数xSemaphoreGiveFromISR()释放信号量</p>
</li>
</ol>
<h2 id="二值信号量相关函数"><a href="#二值信号量相关函数" class="headerlink" title="二值信号量相关函数"></a>二值信号量相关函数</h2><h3 id="二值信号量创建函数"><a href="#二值信号量创建函数" class="headerlink" title="二值信号量创建函数"></a>二值信号量创建函数</h3><p>此函数创建的二值信号量的话信号量所需的RAM是由FreeRTOS的内存管理部分来动态分配的。此函数创建好的二值信号量默认是空的，也就是说刚创建好的二值信号量使用函数xSemaphoreTake()是获取不到的。</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 创建二值信号量 */</span>
SemaphoreHandle_t <span class="token function">xSemaphoreCreateBinary</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span></code></pre>
<p><strong>参数</strong></p>
<p>无</p>
<p><strong>返回值</strong></p>
<p>NULL: 二值信号量创建失败</p>
<p>其他值: 创建成功的二值信号量的句柄</p>
<hr>
<h3 id="释放信号量函数"><a href="#释放信号量函数" class="headerlink" title="释放信号量函数"></a>释放信号量函数</h3><p>此函数用于释放二值信号量，计数型信号量或互斥信号量。</p>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xSemaphoreGive</span><span class="token punctuation">(</span> xSemaphore <span class="token punctuation">)</span></code></pre>
<p><strong>参数</strong></p>
<p>xSemaphore: 要释放的信号量句柄</p>
<p><strong>返回值</strong></p>
<p>pdPASS: 释放信号量成功</p>
<p>errQUEUE_FULL: 释放信号量失败。</p>
<p>xSemaphoreGiveFromISR这是它的中断版本</p>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xSemaphoreGiveFromISR</span><span class="token punctuation">(</span> SemaphoreHandle_t xSemaphore<span class="token punctuation">,</span> 
                                 BaseType_t <span class="token operator">*</span> pxHigherPriorityTaskWoken<span class="token punctuation">)</span></code></pre>
<p><strong>参数</strong></p>
<p>xSemaphore: 要释放的信号量句柄</p>
<p>pxHigherPriorityTaskWoken: 标记退出此函数以后是否进行任务切换，这个变量的值由标记退出此函数以后是否进行任务切换，这个变量的值由三个函数来设置的，用户不用进行设置，用户只需要提供一个变量来保存这个值就行了。当此值为pdTRUE的时候在退出中断服务函数之前一定要进行一次任务切换</p>
<p><strong>返回值</strong></p>
<p>pdPASS: 释放信号量成功</p>
<p>errQUEUE_FULL: 释放信号量失败。</p>
<hr>
<h3 id="获取信号量函数"><a href="#获取信号量函数" class="headerlink" title="获取信号量函数"></a>获取信号量函数</h3><p>此函数用于获取二值信号量，计数型信号量或互斥信号量</p>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xSemaphoreTake</span><span class="token punctuation">(</span>SemaphoreHandle_t xSemaphore<span class="token punctuation">,</span> 
                          ickType_t xBlockTime<span class="token punctuation">)</span></code></pre>
<p><strong>参数</strong></p>
<p>xSemaphore: 要获取的信号量句柄</p>
<p>xBlockTime: 阻塞时间</p>
<p><strong>返回值</strong></p>
<p>pdPASS: 获取信号量成功</p>
<p>pdFALSE: 超时，获取信号量失败。</p>
<p>xSemaphoreTakeFromISR是他的中断版本</p>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xSemaphoreTakeFromISR</span><span class="token punctuation">(</span>SemaphoreHandle_t xSemaphore<span class="token punctuation">,</span> 
                                 BaseType_t <span class="token operator">*</span> pxHigherPriorityTaskWoken<span class="token punctuation">)</span></code></pre>
<p><strong>参数</strong></p>
<p>xSemaphore: 要获取的信号量句柄</p>
<p>xBlockTipxHigherPriorityTaskWoken：标记退出此函数以后是否进行任务切换，这个变量的值由标记退出此函数以后是否进行任务切换，这个变量的值由三个函数来设置的，用户不用进行设置，用户只需要提供一个变量来保存这个值就行了。当此值为pdTRUE的时候在退出中断服务函数之前一定要进行一次任务切换</p>
<p><strong>返回值</strong></p>
<p>pdPASS: 获取信号量成功</p>
<p>pdFALSE: 超时，获取信号量失败。</p>
]]></content>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>图床测试</title>
    <url>/2021/05/24/%E5%B0%8F%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><p>利用 STM32 驱动 AD9833 并调整它的频率</p>
<p>由于我没有电源，所以不能再外接运放来调整它的幅值，暂时先调整频率</p>
<p>再利用STM32的ADC去采集AD9833的输出信号，并存储在数组中做一次4096点的FFT变换</p>
<p><img src="https://i.loli.net/2021/05/22/APKmQMbhI7BVYOy.png" alt="QQ23.png"></p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/QQ%E6%88%AA%E5%9B%BE20210513185912.png" alt="gitee的图床测试"></p>
]]></content>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>CubeMX F407串口以及串口中断的使用</title>
    <url>/2021/05/26/CubeMX%20F407%E4%B8%B2%E5%8F%A32%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​    最近赶上电赛，为了驱动串口屏，同时方便调试，所以尝试着用串口2来为串口屏发送数据，串口1用于显示数据来进行调试</p>
<p>如图是STM32F407的串口引脚分布图</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210524224325.png" alt="STM32F407串口分布图"></p>
<p>F407 系统控制器有四个 USART 和两个 UART，其中USART1和USART2时钟来源于 APB2 总线时钟，其最大频率为 84MHz，其他四个的时钟来源于 APB1 总线时钟，其最大频率为 42MHz。UART 只是异步传输功能，所以没有 SCLK、nCTS 和 nRTS 功能引脚。</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210524224926.png" alt="##"></p>
<a id="more"></a>

<h2 id="工程的建立"><a href="#工程的建立" class="headerlink" title="工程的建立"></a>工程的建立</h2><p>这里我选择了串口1,2并且都将他们的通讯方式都设置为了<code>Asynchronous</code>异步通讯</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210524225026.png" style="zoom:67%;">

<img src="/2021/05/26/CubeMX%20F407%E4%B8%B2%E5%8F%A32%E7%9A%84%E4%BD%BF%E7%94%A8/Users\asus\AppData\Roaming\Typora\typora-user-images\1621867844892.png" alt="1621867844892" style="zoom:67%;">

<p>并且将他们的串口中断都打开</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210524225435.png"></p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210524225500.png"></p>
<p>接着生成代码即可</p>
<h2 id="串口发送代码"><a href="#串口发送代码" class="headerlink" title="串口发送代码"></a>串口发送代码</h2><p>由于我这里是为了在串口屏幕上画曲线，而每个数据的结尾是以三个0xff来结尾的，这里就可以先把三个0xff定义为一个数组</p>
<pre class=" language-c"><code class="language-c">  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>
    uint8_t HexEnd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">0xff</span><span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    uint8_t aTxBuffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"add 1,0,100"</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span></code></pre>
<p>之后可以利用串口2来显示我发送的字符串，利用串口1来为串口屏传输数据</p>
<pre class=" language-c"><code class="language-c"><span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span>aTxBuffer<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>aTxBuffer<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span>HexEnd<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>HexEnd<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart2<span class="token punctuation">,</span>aTxBuffer<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>aTxBuffer<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart2<span class="token punctuation">,</span>HexEnd<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>HexEnd<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><em>这里的格式已经较标准了，以后可以利用此来作为参考</em></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>串口助手已经正确的显示出来了</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210526201529.png" alt="串口助手"></p>
<p>串口屏也已经正确的显示出来了</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210526201747.png" alt="串口屏显示"></p>
<p><em>之后再利用DAC输出正弦波来采集吧</em></p>
]]></content>
      <tags>
        <tag>电赛</tag>
      </tags>
  </entry>
  <entry>
    <title>CubeMX F407 DAC输出正弦波</title>
    <url>/2021/05/27/CubeMX%20F407%20DAC%E8%BE%93%E5%87%BA%E6%AD%A3%E5%BC%A6%E6%B3%A2/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    简单说下思路，STM32自带一个两路独立输出的DAC。要输出正弦波，实质是要控制 DAC 以 v=sin(t)的正弦函数关系输出电压，其中 v 为电压输出，t 为时间。 而由于模拟信号连续而数字信号是离散的，所以使用 DAC 产生正弦波时，只能按一定时间间隔输出正弦曲线上的点，在该时间段内输出相同的电压值，若缩短时间间隔，提高单个周期内的输出点数，可以得到逼近连续正弦波的图形，见下图 37-3，若在外部电路加上适当的电容滤波，可得到更完美的图形。</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210526235059.png" alt="正弦波" style="zoom:50%;">

<p>​    由于正弦曲线是周期函数，所以只需要得到单个周期内的数据后按周期重复即可，而单个周期内取样输出的点数又是有限的，所以为了得到呈 v=sin(t)函数关系电压值的数据通常不会实时计算获取，而是预先计算好函数单个周期内的电压数据表，并且转化成以 DAC 寄存器表示的值。 如 sin 函数值的范围为[-1: +1]，而 STM32 的 DAC 输出电压范围为[0~3.3]V，按 12 位 DAC 分辨率表示的方法，可写入寄存器的最大值为 212 = 4096，即范围为[0:4096]。所以，实际输出时，会进行如下处理：</p>
<blockquote>
<ol>
<li>抬升 sin 函数的输出为正值：v = sin(t)+1 ，此时，v 的输出范围为[0:2]；</li>
<li>扩展输出至 DAC 的全电压范围: v = 3.3*(sin(t)+1)/2 ，此时，v 的输出范围为[0:3.3]， 正是 DAC 的电压输出范围，扩展至全电压范围可以充分利用 DAC 的分辨率；</li>
<li>把电压值以 DAC 寄存器的形式表示：Reg_val = 212/3.3 * v = 211*(sin(t)+1)，此时，存储到 DAC 寄存器的值范围为[0:4096]；</li>
<li>实践证明，在 sin(t)的单个周期内，取 32 个点进行电压输出已经能较好地还原正弦波形，所以在 t∈[0:2π]区间内等间距根据上述 Reg_val 公式运算得到 32 个寄存器值，即可得到正弦波表；</li>
<li>控制 DAC 输出时，每隔一段相同的时间从上述正弦波表中取出一个新数据进行输出，即可输出正弦波。改变间隔时间的单位长度，可以改变正弦波曲线的周期。</li>
</ol>
</blockquote>
<p>所以正弦波表如下</p>
<pre class=" language-c"><code class="language-c">uint16_t Sine12bit<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token number">2048</span>    <span class="token punctuation">,</span> <span class="token number">2460</span>    <span class="token punctuation">,</span> <span class="token number">2856</span>    <span class="token punctuation">,</span> <span class="token number">3218</span>    <span class="token punctuation">,</span> <span class="token number">3532</span>    <span class="token punctuation">,</span> <span class="token number">3786</span>    <span class="token punctuation">,</span> <span class="token number">3969</span>    <span class="token punctuation">,</span> <span class="token number">4072</span>    <span class="token punctuation">,</span>
    <span class="token number">4093</span>    <span class="token punctuation">,</span> <span class="token number">4031</span>    <span class="token punctuation">,</span> <span class="token number">3887</span>    <span class="token punctuation">,</span> <span class="token number">3668</span>    <span class="token punctuation">,</span> <span class="token number">3382</span>    <span class="token punctuation">,</span> <span class="token number">3042</span>    <span class="token punctuation">,</span><span class="token number">2661</span>    <span class="token punctuation">,</span> <span class="token number">2255</span>    <span class="token punctuation">,</span> 
    <span class="token number">1841</span>    <span class="token punctuation">,</span> <span class="token number">1435</span>    <span class="token punctuation">,</span> <span class="token number">1054</span>    <span class="token punctuation">,</span> <span class="token number">714</span>    <span class="token punctuation">,</span> <span class="token number">428</span>    <span class="token punctuation">,</span> <span class="token number">209</span>    <span class="token punctuation">,</span> <span class="token number">65</span>    <span class="token punctuation">,</span> <span class="token number">3</span>        <span class="token punctuation">,</span>
    <span class="token number">24</span>        <span class="token punctuation">,</span> <span class="token number">127</span>    <span class="token punctuation">,</span> <span class="token number">310</span>    <span class="token punctuation">,</span> <span class="token number">564</span>    <span class="token punctuation">,</span> <span class="token number">878</span>    <span class="token punctuation">,</span> <span class="token number">1240</span>    <span class="token punctuation">,</span> <span class="token number">1636</span>    <span class="token punctuation">,</span> <span class="token number">2048</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre>
<h2 id="CubeMX以及代码的配置"><a href="#CubeMX以及代码的配置" class="headerlink" title="CubeMX以及代码的配置"></a>CubeMX以及代码的配置</h2><h3 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h3><img src="https://gitee.com/seekerwj/pic/raw/master/20210527000102.png" alt="DAC" style="zoom:67%;">

<ul>
<li><p><strong>OUT1/2 Configuration</strong>： </p>
<p>对应着两个输出通道</p>
</li>
<li><p><strong>External Trigger</strong>： </p>
<p>是否使用外部中断触发 <code>外部中断EXTI9 触发</code> 就是使用外部中断来触发DAC。 </p>
</li>
<li><p><strong>Output Buffer</strong>： </p>
<p>使能DAC输出缓存。 </p>
<blockquote>
<p>DAC 集成了 2 个输出缓存，可以用来减少输出阻抗，无需外部运放即可直接驱动外部负载。每个 DAC 通道输出缓存可以通过设置 DAC_CR 寄存器的 BOFFx 位来使能或者关闭。如果带载能力还不行，后面就接一个电压跟随器，选择运放一定要选择电流大的型号。<br>使能输出缓冲后，DAC 输出的最小电压为 0.2V，最大电压为 VREF±0.2，而未使能输出缓冲则输出可达到0V。</p>
</blockquote>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210527000530.png" alt="DACBUFF"></p>
</li>
<li><p><strong>Trigger</strong>： </p>
<p>选择DAC的触发方式</p>
<p><code>Timer 2/4/5/6/7/8 Trigger Out event</code> 定时器触发，利用这种方式可以输出特定的波形。在这里我们选择定时器2。 </p>
<p><code>Software trigger</code> 软件触发，在本模式下，向 DAC_SWTRIGR 寄存器写入配置即可触发信号进行转换。 </p>
</li>
<li><p><strong>Wave generation mode</strong>：</p>
<p>波形发生器的选择，有三角波，和噪声，由于这里我们要输出正弦波，所以就不选择了</p>
</li>
</ul>
<a id="more"></a>

<h3 id="DMA的配置"><a href="#DMA的配置" class="headerlink" title="DMA的配置"></a>DMA的配置</h3><p><img src="https://gitee.com/seekerwj/pic/raw/master/20210527011819.png" alt="DACDMA"></p>
<ul>
<li><p><strong>Priority</strong>： </p>
<p>当发生多个 DMA 通道请求时，就意味着有先后响应处理的顺序问题，这个就由仲裁器也管理。仲裁器管理 DMA 通道请求分为两个阶段。第一阶段属于软件阶段，可以在 DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级。第二阶段属于硬件阶段，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通 道编号，编号越低优先权越高，比如通道 0 高于通道 1。在大容量产品和互联型产品中，DMA1 控制器拥有高于 DMA2 控制器的优先级。</p>
</li>
<li><p><strong>Mode</strong>： </p>
<p><code>Normal</code> 表示单次传输，传输一次后终止传输。<br><code>Circular</code> 表示循环传输，传输完成后又重新开始继续传输，不断循环永不停止。（还是从内存的首地址）</p>
</li>
<li><p><strong>Increment Address</strong>： </p>
<p><code>Peripheral</code> 表示外设地址自增。</p>
<p><code>Memory</code> 表示内存地址自增。 </p>
</li>
<li><p><strong>Data Width</strong>： </p>
<p><code>Byte</code> 一个字节。 </p>
<p><code>Half Word</code> 半个字，等于两字节。 </p>
<p><code>Word</code> 一个字，等于四字节。 </p>
</li>
</ul>
<h3 id="TIM"><a href="#TIM" class="headerlink" title="TIM"></a>TIM</h3><img src="https://gitee.com/seekerwj/pic/raw/master/20210527000802.png" alt="TIM" style="zoom:67%;">

<ul>
<li><strong>Prescaler（时钟预分频数）：</strong><code>则驱动计数器的时钟 CK_CNT = CK_INT(即84MHz)/(0+1) = 84MHz</code> 即不分频</li>
<li><strong>Counter Mode（计数模式）：Up（向上计数模式）</strong></li>
<li><strong>Counter Period（自动重装载值）：525-1</strong></li>
<li><strong>auto-reload-preload（自动重装载）：Disable（不使能）</strong>（PWM时使用）</li>
<li><strong>TRGO Parameters（触发输出）：Update Event（更新事件）</strong> <code>在定时器的定时时间到达的时候输出一个信号(如：定时器更新产生TRGO信号来触发ADC的同步转换)</code></li>
</ul>
<h3 id="关于DAC输出的频率计算"><a href="#关于DAC输出的频率计算" class="headerlink" title="关于DAC输出的频率计算"></a>关于DAC输出的频率计算</h3><img src="https://gitee.com/seekerwj/pic/raw/master/20210527003519.png" alt="HZ" style="zoom:67%;">

<p>参考野火STM32F103手册来计算</p>
<p>STM32F407时钟如图</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210527003755.png" alt="clock" style="zoom:67%;">

<img src="https://gitee.com/seekerwj/pic/raw/master/20210527004202.png" alt="TIMCLOCK" style="zoom:67%;">

<p>f = 84000000/1 * 525 * 32 = 5000 Hz</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private typedef -----------------------------------------------------------*/</span>
<span class="token comment" spellcheck="true">/* USER CODE BEGIN PTD */</span>

uint16_t Sine12bit<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token number">2048</span>    <span class="token punctuation">,</span> <span class="token number">2460</span>    <span class="token punctuation">,</span> <span class="token number">2856</span>    <span class="token punctuation">,</span> <span class="token number">3218</span>    <span class="token punctuation">,</span> <span class="token number">3532</span>    <span class="token punctuation">,</span> <span class="token number">3786</span>    <span class="token punctuation">,</span> <span class="token number">3969</span>    <span class="token punctuation">,</span> <span class="token number">4072</span>    <span class="token punctuation">,</span>
    <span class="token number">4093</span>    <span class="token punctuation">,</span> <span class="token number">4031</span>    <span class="token punctuation">,</span> <span class="token number">3887</span>    <span class="token punctuation">,</span> <span class="token number">3668</span>    <span class="token punctuation">,</span> <span class="token number">3382</span>    <span class="token punctuation">,</span> <span class="token number">3042</span>    <span class="token punctuation">,</span><span class="token number">2661</span>    <span class="token punctuation">,</span> <span class="token number">2255</span>    <span class="token punctuation">,</span> 
    <span class="token number">1841</span>    <span class="token punctuation">,</span> <span class="token number">1435</span>    <span class="token punctuation">,</span> <span class="token number">1054</span>    <span class="token punctuation">,</span> <span class="token number">714</span>    <span class="token punctuation">,</span> <span class="token number">428</span>    <span class="token punctuation">,</span> <span class="token number">209</span>    <span class="token punctuation">,</span> <span class="token number">65</span>    <span class="token punctuation">,</span> <span class="token number">3</span>        <span class="token punctuation">,</span>
    <span class="token number">24</span>        <span class="token punctuation">,</span> <span class="token number">127</span>    <span class="token punctuation">,</span> <span class="token number">310</span>    <span class="token punctuation">,</span> <span class="token number">564</span>    <span class="token punctuation">,</span> <span class="token number">878</span>    <span class="token punctuation">,</span> <span class="token number">1240</span>    <span class="token punctuation">,</span> <span class="token number">1636</span>    <span class="token punctuation">,</span> <span class="token number">2048</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/* USER CODE END PTD */</span>

<span class="token comment" spellcheck="true">/* Private define ------------------------------------------------------------*/</span>
<span class="token comment" spellcheck="true">/* USER CODE BEGIN PD */</span>
<span class="token comment" spellcheck="true">/* USER CODE END PD */</span>

<span class="token comment" spellcheck="true">/* Private macro -------------------------------------------------------------*/</span>
<span class="token comment" spellcheck="true">/* USER CODE BEGIN PM */</span>

<span class="token comment" spellcheck="true">/* USER CODE END PM */</span>

<span class="token comment" spellcheck="true">/* Private variables ---------------------------------------------------------*/</span>

<span class="token comment" spellcheck="true">/* USER CODE BEGIN PV */</span>

<span class="token comment" spellcheck="true">/* USER CODE END PV */</span>

<span class="token comment" spellcheck="true">/* Private function prototypes -----------------------------------------------*/</span>
<span class="token keyword">void</span> <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* USER CODE BEGIN PFP */</span>

<span class="token comment" spellcheck="true">/* USER CODE END PFP */</span>

<span class="token comment" spellcheck="true">/* Private user code ---------------------------------------------------------*/</span>
<span class="token comment" spellcheck="true">/* USER CODE BEGIN 0 */</span>

<span class="token comment" spellcheck="true">/* USER CODE END 0 */</span>

<span class="token comment" spellcheck="true">/**
  * @brief  The application entry point.
  * @retval int
  */</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>

  <span class="token comment" spellcheck="true">/* USER CODE END 1 */</span>

  <span class="token comment" spellcheck="true">/* MCU Configuration--------------------------------------------------------*/</span>

  <span class="token comment" spellcheck="true">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">/* USER CODE BEGIN Init */</span>

  <span class="token comment" spellcheck="true">/* USER CODE END Init */</span>

  <span class="token comment" spellcheck="true">/* Configure the system clock */</span>
  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">/* USER CODE BEGIN SysInit */</span>

  <span class="token comment" spellcheck="true">/* USER CODE END SysInit */</span>

  <span class="token comment" spellcheck="true">/* Initialize all configured peripherals */</span>
  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_DMA_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_USART2_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_DAC_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_TIM2_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>
<span class="token comment" spellcheck="true">//    uint8_t HexEnd[] = &amp;#123;0xff, 0xff, 0xff&amp;#125;;</span>


<span class="token comment" spellcheck="true">//    uint8_t aTxBuffer[100] = "add 1,0,100";</span>

  <span class="token function">HAL_TIM_Base_Start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启DAC</span>
  <span class="token function">HAL_DAC_Start_DMA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hdac<span class="token punctuation">,</span> DAC_CHANNEL_1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint32_t <span class="token operator">*</span><span class="token punctuation">)</span>Sine12bit<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> DAC_ALIGN_12B_R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使能DAC——DMA方式</span>

  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span></code></pre>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://gitee.com/seekerwj/pic/raw/master/20210527004805.png" alt="LOTO"></p>
<h2 id="一点小总结"><a href="#一点小总结" class="headerlink" title="一点小总结"></a>一点小总结</h2><ol>
<li><p>DAC的DMA模式其实就是每当触发源触发一次，DMA就像DAC的DHRX寄存器更新一次数据，DAC也将DHRX中的数据再传输到DORX寄存器中，转换为电压输出</p>
<pre class=" language-c"><code class="language-c"><span class="token function">HAL_DAC_Start_DMA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hdac<span class="token punctuation">,</span> DAC_CHANNEL_1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint32_t <span class="token operator">*</span><span class="token punctuation">)</span>Sine12bit<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> DAC_ALIGN_12B_R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使能DAC——DMA方式</span></code></pre>
<p>实际上32就是以<code>Sine12bit</code>数组的首地址为首地址，依次向后的32组数据，每次触发源触发一次DMA就传输一组数据，直到32组数据都传输完成，这时再从头开始传输数据，这样循环下去，就可以配合TIM来实现输出正弦波的功能</p>
</li>
<li><img src="https://gitee.com/seekerwj/pic/raw/master/20210527005511.png" alt="DAC寄存器" style="zoom:67%;">
</li>
<li><p>通过这次实验，以后也可以尝试利用TIM来作为触发其他外设启动的一个触发源（ADC同理）</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>电赛</tag>
      </tags>
  </entry>
  <entry>
    <title>CubeMX F407 利用TIM输入捕获来测量方波的频率与占空比</title>
    <url>/2021/05/29/CubeMX%20F407%20%E5%88%A9%E7%94%A8TIM%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%9D%A5%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%A2%E7%9A%84%E9%A2%91%E7%8E%87%E4%B8%8E%E5%8D%A0%E7%A9%BA%E6%AF%94/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>主要是利用到了STM32的TIM输入捕获功能</p>
<p>将定时器设置为1MHZ的计数频率，定时计数器增加一就是增加1us</p>
<ol>
<li>首先设置为上升沿捕获，捕获上升沿记录此刻的时间计数值；</li>
<li>然后切换为下降沿捕获，捕获下降沿记录此刻的时间计数值；</li>
<li>最后设置为上升沿捕获，捕获上升沿记录此刻的时间计数值；</li>
</ol>
<p>对于16bit定时器，最大可计数0xFFFF，也就是65535us，那么：*<em>高电平持续的时间 = 定时器溢出计数 * 0xFFFF + 当前计数值*</em><br>对于32bit定时器，最大可计数0xFFFFFFFF，也就是4294.967295s，这个时间足够测量脉冲宽度的了，那么：<strong>高电平持续的时间 = 当前计数值</strong></p>
<p><strong>高电平持续的时间 = ② - ①</strong><br><strong>周期 = ③ - ①</strong> </p>
<a id="more"></a>

<h2 id="CubeMX以及代码的配置"><a href="#CubeMX以及代码的配置" class="headerlink" title="CubeMX以及代码的配置"></a>CubeMX以及代码的配置</h2><h3 id="TIM"><a href="#TIM" class="headerlink" title="TIM"></a>TIM</h3><p><img src="https://gitee.com/seekerwj/pic/raw/master/20210528013704.png" alt="TIM配置"></p>
<ul>
<li><p><strong>Clock Source: 时钟源，这里选择内部时钟</strong></p>
</li>
<li><p><strong>Channl1: 通道功能，这里就选择<code>Input Capture direct mode</code>直接输入捕获模式</strong></p>
</li>
<li><p><strong>Prescale: 分频这里就选择83，计算下来正好就是1us一次计数</strong></p>
</li>
<li><p><strong>Count Perid: 计数器，这里就设置成最大值就好，由于TIM3是16bits的所以最大就是65335还需要考虑一下定时器溢出的问题，之后可以采用TIM5，那是32bits的计数器，几乎可以不用考虑计数溢出的问题</strong></p>
</li>
<li><p><strong>Polarity Selection: 捕获极性设置，这里选择上升沿捕获</strong></p>
</li>
<li><p><strong>Input Filter: 滤波器系数，这里暂时先不滤波</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210528013756.png" alt="NVIC"></p>
<p>这里注意开启TIM3的中断，因为之后需要使用输入捕获中断（就是每捕获到一次目标就会进入一次中断）</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210528013859.png" alt="GPIO"></p>
<p>这里需要将GPIO配置下，将GPIO设置为下拉输入，目的就是为了确保当没有信号输入的时候IO口的电平保持稳定</p>
<h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><h4 id="在tim-c中"><a href="#在tim-c中" class="headerlink" title="在tim.c中"></a>在tim.c中</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 0 */</span>

__IO uint32_t TIM3_TIMEOUT_COUNT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">///&lt; 定时器3定时溢出计数</span>
uint32_t TIM3_CAPTURE_BUF<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">///&lt; 分别存储上升沿计数、下降沿计数、下个上升沿计数</span>
__IO uint8_t TIM3_CAPTURE_STA <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">///&lt; 状态标记,默认是不测量的状态</span>

<span class="token comment" spellcheck="true">/* USER CODE END 0 */</span>

<span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>

<span class="token comment" spellcheck="true">/**
 * 设置TIM3输入捕获极性
 * @param TIM_ICPolarity：
 *        TIM_INPUTCHANNELPOLARITY_RISING  ：上升沿捕获
 *        TIM_INPUTCHANNELPOLARITY_FALLING ：下降沿捕获
 *        TIM_INPUTCHANNELPOLARITY_BOTHEDGE：上升沿和下降沿都捕获
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">TIM3_SetCapturePolarity</span><span class="token punctuation">(</span>uint32_t TIM_ICPolarity<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    htim3<span class="token punctuation">.</span>Instance<span class="token operator">-></span>CCER <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>TIM_CCER_CC1P <span class="token operator">|</span> TIM_CCER_CC1NP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    htim3<span class="token punctuation">.</span>Instance<span class="token operator">-></span>CCER <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>TIM_ICPolarity <span class="token operator">&amp;</span> <span class="token punctuation">(</span>TIM_CCER_CC1P <span class="token operator">|</span> TIM_CCER_CC1NP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 定时器3时间溢出回调函数</span>
<span class="token keyword">void</span> <span class="token function">HAL_TIM_PeriodElapsedCallback</span><span class="token punctuation">(</span>TIM_HandleTypeDef <span class="token operator">*</span>htim<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>htim<span class="token operator">-></span>Instance <span class="token operator">==</span> htim3<span class="token punctuation">.</span>Instance<span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        TIM3_TIMEOUT_COUNT<span class="token operator">++</span><span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">// 溢出次数计数</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">///&lt; 输入捕获回调函数</span>
<span class="token keyword">void</span> <span class="token function">HAL_TIM_IC_CaptureCallback</span><span class="token punctuation">(</span>TIM_HandleTypeDef <span class="token operator">*</span>htim<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>htim<span class="token operator">-></span>Instance <span class="token operator">==</span> htim3<span class="token punctuation">.</span>Instance<span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>TIM3_CAPTURE_STA<span class="token punctuation">)</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//printf("准备捕获下降沿...\r\n");</span>
            TIM3_CAPTURE_BUF<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">HAL_TIM_ReadCapturedValue</span><span class="token punctuation">(</span>htim<span class="token punctuation">,</span> TIM_CHANNEL_1<span class="token punctuation">)</span> <span class="token operator">+</span> TIM3_TIMEOUT_COUNT <span class="token operator">*</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>
            <span class="token function">TIM3_SetCapturePolarity</span><span class="token punctuation">(</span>TIM_INPUTCHANNELPOLARITY_FALLING<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 设置为下降沿触发</span>
            TIM3_CAPTURE_STA<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//printf("准备捕获下个上升沿...\r\n");</span>
            TIM3_CAPTURE_BUF<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">HAL_TIM_ReadCapturedValue</span><span class="token punctuation">(</span>htim<span class="token punctuation">,</span> TIM_CHANNEL_1<span class="token punctuation">)</span> <span class="token operator">+</span> TIM3_TIMEOUT_COUNT <span class="token operator">*</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>
            <span class="token function">TIM3_SetCapturePolarity</span><span class="token punctuation">(</span>TIM_INPUTCHANNELPOLARITY_RISING<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 设置为上升沿触发</span>
            TIM3_CAPTURE_STA<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//printf("捕获结束...\r\n");</span>
            <span class="token comment" spellcheck="true">//printf("# end ----------------------------------------------------\r\n");</span>
            TIM3_CAPTURE_BUF<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">HAL_TIM_ReadCapturedValue</span><span class="token punctuation">(</span>htim<span class="token punctuation">,</span> TIM_CHANNEL_1<span class="token punctuation">)</span> <span class="token operator">+</span> TIM3_TIMEOUT_COUNT <span class="token operator">*</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>
            <span class="token function">HAL_TIM_IC_Stop_IT</span><span class="token punctuation">(</span>htim<span class="token punctuation">,</span> TIM_CHANNEL_1<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">// 停止捕获</span>
            <span class="token function">HAL_TIM_Base_Stop_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                <span class="token comment" spellcheck="true">// 停止定时器更新中断</span>
            TIM3_CAPTURE_STA<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//&lt; TIM3轮训状态切换</span>
<span class="token keyword">void</span> <span class="token function">TIM3_Poll</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>TIM3_CAPTURE_STA<span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//printf("# start ----------------------------------------------------\r\n");</span>
        <span class="token comment" spellcheck="true">//printf("准备捕获上升沿...\r\n");</span>
        TIM3_TIMEOUT_COUNT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">__HAL_TIM_SET_COUNTER</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// 清除定时器2现有计数</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>TIM3_CAPTURE_BUF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TIM3_CAPTURE_BUF<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 清除捕获计数</span>
        <span class="token function">TIM3_SetCapturePolarity</span><span class="token punctuation">(</span>TIM_INPUTCHANNELPOLARITY_RISING<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 设置为上升沿触发</span>
        <span class="token function">HAL_TIM_Base_Start_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                <span class="token comment" spellcheck="true">// 启动定时器更新中断</span>
        <span class="token function">HAL_TIM_IC_Start_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">,</span> TIM_CHANNEL_1<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">// 启动捕获中断</span>
        TIM3_CAPTURE_STA<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        uint32_t high  <span class="token operator">=</span> TIM3_CAPTURE_BUF<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> TIM3_CAPTURE_BUF<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        uint32_t cycle <span class="token operator">=</span> TIM3_CAPTURE_BUF<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> TIM3_CAPTURE_BUF<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">double</span> frq <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>cycle<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000000.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TIM3_CAPTURE_STA<span class="token operator">++</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\r\n\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"################################# START #########################################\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"高电平持续时间：%dms\r\n"</span><span class="token punctuation">,</span> high <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"周期          ：%dms\r\n"</span><span class="token punctuation">,</span> cycle <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"频率          ：%fHz\r\n"</span><span class="token punctuation">,</span> frq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"################################## END ######################################\r\n\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">default</span><span class="token punctuation">:</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/* USER CODE END 1 */</span></code></pre>
<p>基本思路就是</p>
<ol>
<li><p>为了在之后的捕获中断中改变捕获的极性但是HAL库是通过配置结构体进而配置寄存器来实现的，这里最好自己先定义一个函数，函数中就是<code>TIM3_SetCapturePolarity(uint32_t TIM_ICPolarity)</code></p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**
 * 设置TIM3输入捕获极性
 * @param TIM_ICPolarity：
 *        TIM_INPUTCHANNELPOLARITY_RISING  ：上升沿捕获
 *        TIM_INPUTCHANNELPOLARITY_FALLING ：下降沿捕获
 *        TIM_INPUTCHANNELPOLARITY_BOTHEDGE：上升沿和下降沿都捕获
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">TIM3_SetCapturePolarity</span><span class="token punctuation">(</span>uint32_t TIM_ICPolarity<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    htim3<span class="token punctuation">.</span>Instance<span class="token operator">-></span>CCER <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>TIM_CCER_CC1P <span class="token operator">|</span> TIM_CCER_CC1NP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    htim3<span class="token punctuation">.</span>Instance<span class="token operator">-></span>CCER <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>TIM_ICPolarity <span class="token operator">&amp;</span> <span class="token punctuation">(</span>TIM_CCER_CC1P <span class="token operator">|</span> TIM_CCER_CC1NP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>在输入捕获中断中分三步来实现</p>
<ol>
<li>第一次捕获到上升沿后将此时的计数器的值存入<code>TIM3_CAPTURE_BUF[0]</code>并改变捕获极性(下降沿捕获)</li>
<li>捕获到下降沿后将此时的计数器的值存入<code>TIM3_CAPTURE_BUF[1]</code>（此时的TIM3_CAPTURE_BUF[1]-TIM3_CAPTURE_BUF[0]的值就是信号高电平的时间了），再次改变捕获极性（上升沿捕获）</li>
<li>第二次捕获到上升沿后将此时的计数器的值存入<code>TIM3_CAPTURE_BUF[2]</code>（此时TIM3_CAPTURE_BUF[2]-TIM3_CAPTURE_BUF[0]就是信号的周期时间了）</li>
</ol>
</li>
<li><p>建立一个捕获开启函数（状态机）</p>
<ol>
<li><p>首先判断<code>TIM3_CAPTURE_STA</code>即是频率测量是否开启状态位，同时也是状态机的步骤位</p>
<p>开启后需要清零<code>TIM3_TIMEOUT_COUNT</code>计数器变量的值</p>
</li>
<li><p>清零<code>TIM3_TIMEOUT_COUNT</code>计数器变量，清零TIM3现有的计数<code>__HAL_TIM_SET_COUNTER(&amp;htim3, 0);</code>各个状态和标记位,清零捕获计数的数组<code>memset(TIM3_CAPTURE_BUF, 0, sizeof(TIM3_CAPTURE_BUF));</code>，设置为<code> TIM3_SetCapturePolarity(TIM_INPUTCHANNELPOLARITY_RISING);</code>上升沿触发,<code>HAL_TIM_Base_Start_IT(&amp;htim3);</code>启动定时器更新中断,<code>HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_1);</code>启动捕获中断。</p>
</li>
</ol>
</li>
<li><p>执行完以上步骤后<code>TIM3_CAPTURE_STA</code>加1，进而会执行捕获中断中的程序</p>
</li>
<li><p>待到<code>TIM3_CAPTURE_STA</code>置4后（即是已经完成了周期的测量），计算出频率值与高电平持续时间，占空比即可</p>
</li>
</ol>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>这是一个250kHz的方波信号</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210529005541.png" alt="输出"></p>
<p>通过串口输出结果</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210528014619.png" alt="频2率"></p>
<h2 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h2><ol>
<li><p>在利用TIM输入捕获测高电平时间时，因为频繁的在进入捕获中断所以不能有任何中断或者其他事件干扰这个过程。！！比如说不能利用串口发送数据等，总之不能通过CPU再进行其他的一系列操作，只能等待这个捕获过程完成后才可进行其他操作，所以我这里是使用串口发送特定字符使测频程序启动的。</p>
<p>这也是这个TIM输入捕获测频率的一个缺点——占用CPU的频率太高了…不过在没有干扰的情况下测量得到的频率准确性很高几乎没有误差，最高可以测250kHz的方波输出</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210528014619.png" alt="频率"></p>
</li>
<li><p>利用状态机的思维来编程，即是设置轮询步骤位，根据不同的步骤位来进行不同的操作，这种状态机思维常用于某个功能需要多外设或者多模块函数按照特定的顺序来共同完成，通过设置不同模块对应的步骤位可以协调这些模块按步骤顺序来执行。</p>
<p>当需要开启系统中的某个功能时，只需要将步骤位置为相应的起始位，各个模块就可以按照相应的顺序执行。并在最后将步骤位置”END”状态，方便我们在下次需要再次使用带该功能时再将步骤位置起始位。</p>
</li>
<li><p>利用到的函数</p>
<pre class=" language-c"><code class="language-c"><span class="token function">__HAL_TIM_SET_COUNTER</span><span class="token punctuation">(</span> 定时器地址 <span class="token punctuation">,</span> 设置的数值 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置某定时器的计数器值</span>
<span class="token function">TIM2_SetCapturePolarity</span><span class="token punctuation">(</span>捕获触发模式）<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置输入捕获的触发方式</span>
<span class="token function">HAL_TIM_ReadCapturedValue</span><span class="token punctuation">(</span>htim<span class="token punctuation">,</span> TIM_CHANNEL_1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从捕获比较单元读出当前的捕获值</span></code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>电赛</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/2021/07/09/%E4%BB%80%E4%B9%88%E6%98%AF%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>​    对于FPGA而言，它的编程语言是Verilog，这是一款硬件描述语言硬件电路是并行执行的，当需要按照流程或者步骤来完成某个功能时，代码中通常会使用很多个if嵌套语句来实现，这样就增加了代码的复杂度，以及降低了代码的可读性，这个时候就可以使用状态机来编写代码。</p>
<p>​    状态机相当于一个控制器，它将一项功能的完成分解为若干步，每一步对应于二进制的一个状态，通过预先设计的顺序在各状态之间进行转换，状态转换的过程就是实现逻辑功能的过程。</p>
<h3 id="有限状态机-Finite-State-Machine-FSM"><a href="#有限状态机-Finite-State-Machine-FSM" class="headerlink" title="有限状态机(Finite State Machine/FSM)"></a>有限状态机(Finite State Machine/FSM)</h3><p>​    在有限个状态之间按一定规律转化的<em>时序电路</em></p>
<h3 id="状态机的种类"><a href="#状态机的种类" class="headerlink" title="状态机的种类"></a>状态机的种类</h3><p>​    根据状态机的输出是否与输入条件相关，可将状态机分为两大类，即摩尔(Moore)型状态机和米勒(Mealy)型状态机。</p>
<a id="more"></a>

<h4 id="Mealy状态机"><a href="#Mealy状态机" class="headerlink" title="Mealy状态机"></a>Mealy状态机</h4><p>​    组合逻辑的输出不仅取决于当前状态，还取决于输入状态。</p>
<p>​    Mealy状态机的模型如下图所示，模型中第一个方框是指产生下一状态的组合逻辑F，F是当前状态和输入信号的函数，状态是否改变、如何改变，取决于组合逻辑F的输出；第二框图是指状态寄存器，其由一组触发器组成，用来记忆状态机当前所处的状态，状态的改变只发生在时钟的跳边沿；第三个框图是指产生输出的组合逻辑G，状态机的输出是由输出组合逻辑G提供的，G也是当前状态和输入信号的函数。</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210709012010.png"></p>
<h4 id="Moore状态机"><a href="#Moore状态机" class="headerlink" title="Moore状态机"></a>Moore状态机</h4><p>​    组合逻辑的输出只取决于当前状态。</p>
<p>​    摩尔状态机的模型如下图所示，对比米勒状态机的模型可以发现，其区别在于米勒状态机的输出由当前状态和输入条件决定的，而摩尔状态机的输出只取决于当前状态。</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210709012557.png"></p>
<hr>
<h2 id="三段式状态机"><a href="#三段式状态机" class="headerlink" title="三段式状态机"></a>三段式状态机</h2><p>​    使用三个always模块，一个always模块采用同步时序描述状态转移，一个always采用组合逻辑判断状态转移条件，描述状态转移规律，另一个always模块描述状态输出(可以用组合电路输出，也可以时序电路输出)。</p>
<h2 id="设计状态机有这么四个步骤"><a href="#设计状态机有这么四个步骤" class="headerlink" title="设计状态机有这么四个步骤"></a>设计状态机有这么四个步骤</h2><h3 id="1-状态空间的定义"><a href="#1-状态空间的定义" class="headerlink" title="1.状态空间的定义"></a>1.状态空间的定义</h3><p>​    <strong>状态空间：</strong>即是各个状态的集合</p>
<p>在定义状态空间的时候，还需要额外定义两个寄存器，即current_state(过去的状态)以及next_state(下一个状态)。</p>
<p>并且在定义状态空间的时候，也可以使用独热码（即每个状态只有一个寄存器位置）类似于FreeRTOS中的信号组，这种定义方式译码更简单。</p>
<pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">parameter</span> S0 <span class="token operator">=</span> <span class="token number">7'b0000001</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//独热码定义方式</span>
<span class="token keyword">parameter</span> S1 <span class="token operator">=</span> <span class="token number">7'b0000010</span><span class="token punctuation">;</span>
<span class="token keyword">parameter</span> S2 <span class="token operator">=</span> <span class="token number">7'b0000100</span><span class="token punctuation">;</span>
<span class="token keyword">parameter</span> S3 <span class="token operator">=</span> <span class="token number">7'b0001000</span><span class="token punctuation">;</span>
<span class="token keyword">parameter</span> S4 <span class="token operator">=</span> <span class="token number">7'b0010000</span><span class="token punctuation">;</span>
<span class="token keyword">parameter</span> S5 <span class="token operator">=</span> <span class="token number">7'b0100000</span><span class="token punctuation">;</span>
<span class="token keyword">parameter</span> S6 <span class="token operator">=</span> <span class="token number">7'b1000000</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//由于是7位的位宽，所以用于存储状态的寄存器也要定义为7位的位宽</span>
<span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> curr_st <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//当前状态</span>
<span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> next_st <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//下一个状态</span></code></pre>
<h3 id="2-状态的跳转（时序逻辑）"><a href="#2-状态的跳转（时序逻辑）" class="headerlink" title="2. 状态的跳转（时序逻辑）"></a>2. 状态的跳转（时序逻辑）</h3><p>​    即满足了当前条件后用来控制当前状态的变化，主要是控制当前状态的变化，并且检测但满足复位条件时将当前状态复位为初始状态。（下一个状态是什么由“下个状态的判断模块来实现”）</p>
<pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sys_rst_n<span class="token punctuation">)</span>
        curr_st <span class="token operator">&lt;=</span> S0<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        curr_st <span class="token operator">&lt;=</span> next_st<span class="token punctuation">;</span>
<span class="token keyword">end</span></code></pre>
<h3 id="3-下个状态的判断"><a href="#3-下个状态的判断" class="headerlink" title="3. 下个状态的判断"></a>3. 下个状态的判断</h3><p>​    用来根据当前的状态判断下个状态是什么</p>
<pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">//状态机的第二段采用组合逻辑判断状态转移条件</span>
<span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">case</span> <span class="token punctuation">(</span>curr_st<span class="token punctuation">)</span>
        S0<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S1<span class="token punctuation">;</span>
        S1<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S2<span class="token punctuation">;</span>
        S2<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S3<span class="token punctuation">;</span>
        S3<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S4<span class="token punctuation">;</span>
        S4<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S5<span class="token punctuation">;</span>
        S5<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S6<span class="token punctuation">;</span>
        S6<span class="token punctuation">:</span> next_st <span class="token operator">=</span> S0<span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span> next_st <span class="token operator">=</span> S0<span class="token punctuation">;</span>
    <span class="token keyword">endcase</span>
<span class="token keyword">end</span></code></pre>
<h3 id="4-各个状态下的工作"><a href="#4-各个状态下的工作" class="headerlink" title="4. 各个状态下的工作"></a>4. 各个状态下的工作</h3><p>​    这里举的例子是时序逻辑电路，但实际上，各个状态下的工作也可以用组合逻辑电路来实现</p>
<p>​    状态机的第三段可以使用组合逻辑电路输出，也可以使用时序逻辑电路输出，一般推荐使用时序电路输出，因为状态机的设计和其它设计一样，最好使用同步时序方式设计，以提高设计的稳定性，消除毛刺。</p>
<pre class=" language-verilog"><code class="language-verilog"><span class="token comment" spellcheck="true">//状态机的第三段描述状态输出（这里采用时序电路输出）</span>
<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_rst_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sys_rst_n<span class="token punctuation">)</span>
        clk_divide_7 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S0<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S1<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S2<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S3<span class="token punctuation">)</span><span class="token punctuation">)</span>
        clk_divide_7 <span class="token operator">&lt;=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S4<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S5<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>curr_st <span class="token operator">==</span> S6<span class="token punctuation">)</span><span class="token punctuation">)</span>
        clk_divide_7 <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token punctuation">;</span>
<span class="token keyword">end</span></code></pre>
<h4 id="状态机采用时序逻辑输出的状态机模型如下图所示："><a href="#状态机采用时序逻辑输出的状态机模型如下图所示：" class="headerlink" title="状态机采用时序逻辑输出的状态机模型如下图所示："></a>状态机采用时序逻辑输出的状态机模型如下图所示：</h4><p><img src="https://gitee.com/seekerwj/pic/raw/master/20210709014655.png"></p>
<p>​    采用这种描述方法虽然代码结构复杂了一些，但是这样做的好处是可以有效地滤去组合逻辑输出的毛刺，同时也可以更好的进行时序计算与约束，另外对于总线形式的输出信号来说，容易使总线数据对齐，减小总线数据间的偏移，从而降低接收端数据采样出错的频率。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>​    事实上状态机不仅仅在FPGA上适用，利用状态机的思想也可用于STM32等嵌入式的程序编写。特别适用于多级菜单这类人机交互界面。</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA流水灯的实现</title>
    <url>/2021/07/12/FPGA%E6%B5%81%E6%B0%B4%E7%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>今天是11号，他妈的，有时候我也搞不懂自己为什么要抱着侥幸心理去做这种乱七八糟没有把握的事情。之后只好硬着头皮弄了。总之先把频率计和AD采样给实现了吧</p>
<h2 id="使用Quartus-II建立第一个工程"><a href="#使用Quartus-II建立第一个工程" class="headerlink" title="使用Quartus II建立第一个工程"></a>使用Quartus II建立第一个工程</h2><p>首先要先新建一个文件夹来存放Quartus的工程文件，要注意的是不要怕存在中文路径，如图</p>
<a id="more"></a>

<p>   doc文件夹用于存放项目相关的文档，par文件夹用于存放Quartus软件的工程文件，rtl文件夹用于存放源代码，sim文件夹用于存放项目的仿真文件。</p>
<p>   <img src="https://gitee.com/seekerwj/pic/raw/master/20210711161123.png"></p>
<p>之后启动Quartus软件</p>
  <img src="https://gitee.com/seekerwj/pic/raw/master/20210711161343.png" style="zoom: 67%;">

<p>Quartus软件默认由菜单栏、工具栏、工程文件导航窗口、编译流程窗口、主编辑窗口以及信息提示窗口组成。在菜单栏上选择【File】→【New Project Wizard…】来新建一个工程。</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210711161502.png" style="zoom:67%;">

<p>新建工程向导说明页面如图，单击NEXT按键进入下一集菜单</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210711162021.png" style="zoom: 80%;">

<p>第一栏用于指定工程所在的路径（就是之前专门新建的文件夹用来存放工程文件的）；</p>
<p>第二栏用于指定工程名，这里建议直接使用顶层文件的实体名作为工程名；</p>
<p>第三栏用于指定顶层文件的实体名。</p>
<p>这里我们设置的工程路径为E:/Verilog/flow_led/par文件夹，工程名与顶层文件的实体名同为Flow_LED。文件名和路径设置完毕后，单击【Next】按钮，可以进入下一个页面</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210711161651.png" style="zoom: 80%;">

<p>在该页面中，可以通过点击【…】符号按钮添加已有的工程设计文件（Verilog或 VHDL文件），由于这里是一个完全新建的工程，没有任何预先可用的设计文件，所以不用添加，直接单击【Next】按钮进入下一级菜单</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210711162158.png" style="zoom: 80%;">

<p>这里要根据实际所用的FPGA型号来选择目标器件，我使用的是凌智电子的FPGA开发板主芯片是Cyclone IV E系列的“EP4CE10E22C8”</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210711170455.png" style="zoom: 80%;">

<p>在“EDA Tool Settings”页面中，可以设置工程各个开发环节中需要用到的第三方EDA工具，比如：仿真工具Modelsim、综合工具Synplify。这里暂不添加任何工具。点击【NEXT】进入下一级菜单</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210711170745.png" style="zoom: 80%;">

<p>从该页面中，可以看到工程文件配置信息报告，接下来我们点击【Finish】完成工程的创建。</p>
<img src="/2021/07/12/FPGA%E6%B5%81%E6%B0%B4%E7%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/Users\asus\AppData\Roaming\Typora\typora-user-images\1625994559917.png" alt="1625994559917" style="zoom:80%;">



<h2 id="设计输入"><a href="#设计输入" class="headerlink" title="设计输入"></a>设计输入</h2><p>​    这里使用Verilog HDL语言来作为工程的输入设计文件，所以在Design Files一栏中选择Verilog HDL File，然后点击【OK】按钮。</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210711171234.png"></p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210711171118.png"></p>
<p>之后就可以看到出现了一个Verilog1.v文件的设计界面，用于输入Verilog代码</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210711171657.png" style="zoom: 67%;">



<hr>
<h2 id="流水灯代码的编写"><a href="#流水灯代码的编写" class="headerlink" title="流水灯代码的编写"></a>流水灯代码的编写</h2><h3 id="模块的输入与输出定义"><a href="#模块的输入与输出定义" class="headerlink" title="模块的输入与输出定义"></a>模块的输入与输出定义</h3><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Flow_LED</span><span class="token punctuation">(</span>
        <span class="token keyword">input</span>               sys_clk<span class="token punctuation">,</span>              <span class="token comment" spellcheck="true">//系统时钟</span>
        <span class="token keyword">input</span>               sys_res_n<span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//系统复位，低电平有效</span>

        <span class="token keyword">output</span> <span class="token keyword">reg</span>      <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>       led        <span class="token comment" spellcheck="true">//定义一个3位的输出寄存器，对应着三个LED灯</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//模块的定义，并且定义了它的输入输出口</span></code></pre>
<p>这里定义了 LED流水灯模块的 系统时钟输入 和 复位时钟输入 并且也定义了 一个3位的输出寄存器 用于控制LED灯的IO口</p>
<p><strong>这里有个要注意的，模块的名称要与工程的名称相同</strong></p>
<h3 id="always块的定义"><a href="#always块的定义" class="headerlink" title="always块的定义"></a>always块的定义</h3><h4 id="always块是用来干什么的？"><a href="#always块是用来干什么的？" class="headerlink" title="always块是用来干什么的？"></a>always块是用来干什么的？</h4><p>​    always块是Verilog中用来描述组合逻辑以及时序逻辑的语法。一个设计中可以有多个always块，或者说一定有很多个always块。</p>
<p>​    这些硬件块都是相互独立同时工作的。每个块之间的连接是决定数据流的原因。为了模拟这种行为，一个always块被做成一个连续的过程（硬件不可能断断续续工作），当敏感列表中的一个信号变化时，它就会被触发并执行一些动作（always块内的语句）。</p>
<h4 id="定时器块"><a href="#定时器块" class="headerlink" title="定时器块"></a>定时器块</h4><p>该定时器定时时长为1.5s，由于晶振是50MHz,所以每次时钟上升沿间隔为20ns，而这里需要设计的是每500ms LED灯改变一次，所以以25000000为一个周期，即500ms。</p>
<p>首先需要定义一个32位的计数寄存器</p>
<pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">reg</span>     <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>      counter<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义了一个32位的计数器寄存器</span></code></pre>
<p>这是一个时序逻辑电路，考虑到有时钟的输入，所以要采用非阻塞式幅值</p>
<pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_res_n<span class="token punctuation">)</span><span class="token keyword">begin</span>
        <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sys_res_n<span class="token punctuation">)</span>
            counter <span class="token operator">&lt;=</span> <span class="token number">32'd0</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">&lt;</span> <span class="token number">32'd74999999</span><span class="token punctuation">)</span>
                counter <span class="token operator">&lt;=</span> counter <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                counter <span class="token operator">&lt;=</span> <span class="token number">32'd0</span><span class="token punctuation">;</span>
<span class="token keyword">end</span></code></pre>
<h4 id="LED控制块"><a href="#LED控制块" class="headerlink" title="LED控制块"></a>LED控制块</h4><p>这是一个时序逻辑电路，考虑到有时钟的输入，所以要采用非阻塞式幅值</p>
<pre class=" language-verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_res_n<span class="token punctuation">)</span><span class="token keyword">begin</span>
    <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sys_res_n<span class="token punctuation">)</span>                            <span class="token comment" spellcheck="true">//当检测到复位信号的时候将所有LED灯熄灭</span>
            led <span class="token operator">&lt;=</span> <span class="token number">3'b111</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token number">32'd24999999</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//当计数值到了25000000，改变一次LED的状态其余同理</span>
            led <span class="token operator">&lt;=</span> <span class="token number">3'b011</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">==</span>  <span class="token number">32'd49999999</span><span class="token punctuation">)</span>
            led <span class="token operator">&lt;=</span> <span class="token number">3'b101</span><span class="token punctuation">;</span>
       <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">==</span>  <span class="token number">32'd74999999</span><span class="token punctuation">)</span>
            led <span class="token operator">&lt;=</span> <span class="token number">3'b110</span><span class="token punctuation">;</span>
       <span class="token keyword">else</span>
      <span class="token punctuation">;</span>
<span class="token keyword">end</span></code></pre>
<h4 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h4><pre class=" language-verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Flow_LED</span><span class="token punctuation">(</span>
        <span class="token keyword">input</span>               sys_clk<span class="token punctuation">,</span>              <span class="token comment" spellcheck="true">//系统时钟</span>
        <span class="token keyword">input</span>               sys_res_n<span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//系统复位，低电平有效</span>

        <span class="token keyword">output</span> <span class="token keyword">reg</span>      <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>       led        <span class="token comment" spellcheck="true">//定义一个3位的输出寄存器，对应着三个LED灯</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//模块的定义，并且定义了它的输入输出口</span>

<span class="token keyword">reg</span>     <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>      counter<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义了一个24位的计数器寄存器</span>


<span class="token comment" spellcheck="true">//main code</span>

<span class="token comment" spellcheck="true">//定时器模块</span>
<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_res_n<span class="token punctuation">)</span><span class="token keyword">begin</span>
        <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sys_res_n<span class="token punctuation">)</span>
            counter <span class="token operator">&lt;=</span> <span class="token number">32'd0</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">&lt;</span> <span class="token number">32'd74999999</span><span class="token punctuation">)</span>
                counter <span class="token operator">&lt;=</span> counter <span class="token operator">+</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                counter <span class="token operator">&lt;=</span> <span class="token number">32'd0</span><span class="token punctuation">;</span>
<span class="token keyword">end</span>

<span class="token comment" spellcheck="true">//LED控制模块</span>
<span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> sys_clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> sys_res_n<span class="token punctuation">)</span><span class="token keyword">begin</span>
        <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sys_res_n<span class="token punctuation">)</span>
            led <span class="token operator">&lt;=</span> <span class="token number">3'b111</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token number">32'd24999999</span><span class="token punctuation">)</span>
            led <span class="token operator">&lt;=</span> <span class="token number">3'b011</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">==</span>  <span class="token number">32'd49999999</span><span class="token punctuation">)</span>
            led <span class="token operator">&lt;=</span> <span class="token number">3'b101</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>counter <span class="token operator">==</span>  <span class="token number">32'd74999999</span><span class="token punctuation">)</span>
            led <span class="token operator">&lt;=</span> <span class="token number">3'b110</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">;</span>
<span class="token keyword">end</span>

<span class="token keyword">endmodule</span>
</code></pre>
<h2 id="管脚分配"><a href="#管脚分配" class="headerlink" title="管脚分配"></a>管脚分配</h2><p>在程序块编写好了之后还需要再为FPGA分配管脚</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210711221552.png" style="zoom:80%;">

<p>双击Location即可为IO口配置管脚，具体管脚参考FPGA开发板的原理图</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210711221937.png"></p>
<h2 id="程序下载"><a href="#程序下载" class="headerlink" title="程序下载"></a>程序下载</h2><p>如图所示，首先得设置用于下载的硬件</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210712000248.png" style="zoom:80%;">

<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210712000157.png"></p>
<p>选择需要下载的文件</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210712000352.png" style="zoom:67%;">

<p>选中文件后，连接好USB-Blaster即可开始下载程序，不顾需要注意的是，该程序的下载是存放在SRAM中的，在此过程中如果芯片掉电，程序将不会保存。如何固化程序见另一篇文章。</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210712000352.png" style="zoom:67%;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>要注意的是所有always块是并行运行的，并且要注意阻塞式赋值与非阻塞式的区别</li>
<li>在描述组合逻辑电路的时候，使用阻塞赋值；在描述时序逻辑电路额的时候，使用非阻塞式赋值。</li>
<li>刚开始解除FPGA，以LED流水灯为例，这也算是一个工程编写的基本步骤</li>
</ol>
]]></content>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>如何把程序固化在FPGA中</title>
    <url>/2021/07/13/%E5%A6%82%E4%BD%95%E6%8A%8A%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%E5%9C%A8FPGA%E4%B8%AD/</url>
    <content><![CDATA[<p>​    在之前的LED流水灯测试中使用的是“<code>.sof</code>”文件格式，这种烧录方式在开发板断电后程序会丢失。如果想在开发板掉电后程序不丢失的话那么就要利用JTAG 烧写“<code>.jic</code>”文件实现程序掉电不丢失。</p>
<p>​    但是<code>.jic</code>文件的生成需要使用<code>.sof</code>来进行转化，手动生成</p>
<h2 id="代码配置以及芯片的选择"><a href="#代码配置以及芯片的选择" class="headerlink" title="代码配置以及芯片的选择"></a>代码配置以及芯片的选择</h2><h3 id="存储芯片的选择（ROM）"><a href="#存储芯片的选择（ROM）" class="headerlink" title="存储芯片的选择（ROM）"></a>存储芯片的选择（ROM）</h3><p>​    要掉电不丢失代码，代码就要存储在ROM 里，<strong>FPGA Cyclone 芯片本身是没有带ROM的，需要外挂这样的存储芯片。</strong>由于外挂怎样的存储芯片和FPGA芯片以及FPGA程序设计有关，因此FPGA软件需要根据外围配置的存储芯片进行选择。</p>
<p>​    凌智电子的FPGA开发板采用的是EPCS4配置芯片， 有时候Quartus II 软件可以自动识别该芯片，为了识别不出错，在使用下载前进行配置选择，并在下载后，先给开发板断电再拔掉下载线，否则代码可能无法生效。</p>
<a id="more"></a>



<hr>
<p>​    首先在菜单栏的<code>Assignments</code>中选择<code>Device</code>，如图</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210713021147.png" style="zoom:80%;">

<p>​    之后选择外设和管脚<code>Device and Pin Options</code></p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210713020945.png" style="zoom:80%;">

<p>​    在<code>Configuartion</code>中将<code>Use configuration device</code>的选项打勾，然后选择配置芯片为EPCS4，之后点击OK完成芯片的配置</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210713021413.png" style="zoom:80%;">



<h3 id="文件的转换"><a href="#文件的转换" class="headerlink" title="文件的转换"></a>文件的转换</h3><p>​    首先打开File选项中的Convert Programming Files，如图</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210713021952.png" style="zoom:80%;">

<p>​    接着在<code>Programming file type</code>里选择要转换输出的文件格式，这里要选择为<code>.jic</code>格式的。接着在<code>Configuration device </code>里选择外部的配置芯片，这里需要选择EPCS4（因为开发板上的的外部配置芯片就是EPCS4）。接着在<code>File name</code>里命名你要输出的文件名和文件存储的目录。（建议选择在Output文件夹中，文件名称建议和工程名称一样，方便辨认）</p>
<img src="/2021/07/13/%E5%A6%82%E4%BD%95%E6%8A%8A%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%E5%9C%A8FPGA%E4%B8%AD/Users\asus\AppData\Roaming\Typora\typora-user-images\1626114110508.png" alt="1626114110508" style="zoom: 67%;">

<p>​    之后选择开发板上的芯片：Cyclone IV E EP4CE10，然后点击“OK”，回到“sof 文件转换为jic 文件”的界面。然后选中“SOF Data”，点击右边的按钮“Add File”，如下图所示。</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210713022842.png" style="zoom:67%;">

<img src="https://gitee.com/seekerwj/pic/raw/master/20210713023010.png" style="zoom:67%;">

<p>完成所有配置之后，点击Generate即可生成文件</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210713023048.png" style="zoom:67%;">



<h3 id="AS-程序下载（程序的固化）"><a href="#AS-程序下载（程序的固化）" class="headerlink" title="AS 程序下载（程序的固化）"></a>AS 程序下载（程序的固化）</h3><p>​    其下载过程与<code>.sop</code>文件的下载类似。</p>
<p>​    首先先将下载文件中的<code>.sop</code>删去</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210713025326.png" style="zoom:67%;">

<p>​    之后也是点击添加文件</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210713025411.png" style="zoom:67%;">

<p>​    添加完成之后，需要在“Program/Configure”方框下面点击打勾，否则“Start”将不能被点击。在这之后点击“Start”，便可开始烧录程序，程序烧录完成后需要先关掉电源，之后拔掉下载器，重新开启电源，即可看到程序已经可以运行了。</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210713025435.png"></p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/VID_20210713_025950.gif"></p>
<p>同理的，想要将原来下载到FLASH中的程序删除，即选中文件的Erase选项，然后点击Start即可等待擦除完成~</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>点亮HPDL-1414</title>
    <url>/2021/09/06/%E7%82%B9%E4%BA%AEHPDL-1414/</url>
    <content><![CDATA[<h2 id="手册中的一些重要信息"><a href="#手册中的一些重要信息" class="headerlink" title="手册中的一些重要信息"></a>手册中的一些重要信息</h2><h3 id="供电电压"><a href="#供电电压" class="headerlink" title="供电电压"></a>供电电压</h3><img src="https://gitee.com/seekerwj/pic/raw/master/20210906155600.png" style="zoom:50%;">



<h3 id="相关引脚与引脚作用"><a href="#相关引脚与引脚作用" class="headerlink" title="相关引脚与引脚作用"></a>相关引脚与引脚作用</h3><img src="https://gitee.com/seekerwj/pic/raw/master/20210906155504.png" style="zoom:50%;">



<p>​    WR信号可以看作触发器的时钟信号，只有WR为低电位时被A0、A1选中的段才会改变，否则显示之前的字符，这样就可以同时控制多个HPDL 1414了，A0、A1、D0~D6都可以复用只要单独控制WR即可。 </p>
<a id="more"></a>



<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>​    这个字符表即是ASCII码表的后7个bit</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210906171512.png"></p>
<p>ASCII表具体如图</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210906171727.png"></p>
<h3 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h3><p>​    D0<del>D6使用来控制字符的显示，A1,A0用来控制时哪一个数码管来显示，并且可以通过WR位来控制多个HPDL_1414,这也说明了A0，A1，D0</del>D6是可以复用的（WR要被拉低了才能控制HPDL1414）。</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210906172112.png" style="zoom:67%;">



<h3 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token keyword">int</span> add<span class="token punctuation">,</span><span class="token keyword">char</span> data<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//add即是A0，A1，用来控制字符显示的位置，data即是D0~D6，用来控制对应位显示的字符</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>add<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//字符显示的位置</span>
      <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">default</span><span class="token punctuation">:</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

  <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token operator">>></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取char的各个bit，即ASCii的后7个bits，将其分配至各自的引脚</span>
  <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token operator">>></span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token operator">>></span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token operator">>></span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//拉低WR引脚，改变状态</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//holdtime，使得触发器能够正确的采样各个引脚的电平（并不用这么久，实际只用200ns）</span>
  <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//拉高WR引脚，防止已经成功保存的状态再次改变</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// put your setup code here, to run once:</span>
  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//D0 8 HPDL_ 1414的管脚功能 HPDL_1414的管脚编号</span>
  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//D1 9</span>
  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//D2 10</span>
  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//D3 11</span>
  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//D4 2</span>
  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//D5 1</span>
  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//D6 12</span>

  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//WR 3</span>
  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//A0 5</span>
  <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span>OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//A1 4</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//  // put your main code here, to run repeatedly:</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'5'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'5'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dispchar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>慢慢来，准备的是先弄一个HPDL1414的驱动测试板来做些测试，要不然用洞洞板和Arduino来测试的话太鸡肋了。</p>
<p>后期将原驱动一个HPDL_1414的驱动函数改为驱动两个HPDL_1414的驱动函数</p>
]]></content>
      <tags>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32 GPIO基本使用</title>
    <url>/2021/09/08/ESP32-C3%20GPIO%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="关于ESP32-C3工程的建立"><a href="#关于ESP32-C3工程的建立" class="headerlink" title="关于ESP32-C3工程的建立"></a>关于ESP32-C3工程的建立</h2><p>​    目前为止，我仍然采用的ESPIDF中的example作为一个最基本的工程，然后在此基础上在加以修改（比较笨，之后找到好的办法再说）</p>
<p>​    <code>Ctrl + shift + p</code>可以打开VSCODE的交互界面</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210908152804.png" style="zoom: 67%;">

<p>之后便可以在这其中选择一个作为工程来创建如图</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210908152843.png" style="zoom:67%;">



<a id="more"></a>



<h2 id="GPIO接口的使用"><a href="#GPIO接口的使用" class="headerlink" title="GPIO接口的使用"></a>GPIO接口的使用</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​    ESP32-C3 芯片有22 个物理通用输入输出管脚(GPIO Pin)。每个管脚都可用作一个通用IO，或连接一个内部的外设信号。利用GPIO 交换矩阵和IO MUX，可配置外设模块的输入信号来源于任何的IO 管脚，并且外设模块的输出信号也可连接到任意IO 管脚。这些模块共同组成了芯片的IO 控制。</p>
<h3 id="关于IO-MUX-以及GPIO-交换矩阵的理解"><a href="#关于IO-MUX-以及GPIO-交换矩阵的理解" class="headerlink" title="关于IO MUX 以及GPIO 交换矩阵的理解"></a>关于IO MUX 以及GPIO 交换矩阵的理解</h3><p>结合IO MUX 以及 GPIO交换矩阵的主要特性，配合着二者的工作流程图不难看出</p>
<p>GPIO交换矩阵主要起一个中继的作用，外部的输入信号，以及内部的输出信号可以通过GPIO交换矩阵来配置，从而达到外设模块的输入信号可以来源于任何的IO管脚，通过内部信号也可以通过交换矩阵配置从而可以从任意一个PIN脚输出。十分灵活（不同于STM32这类，硬件I2C或者硬件SPI就必须是某几个固定的PIN脚）？</p>
<p>IO MUX的主要作用就是为每个GPIO管脚提供一个寄存器的作用，用来配置各个管脚功能。</p>
<p>并且为了实现更好的高频特性，SPI，UART等相关外设也可以不通过GPIO交换矩阵，直接通过IO MUX与PIN脚相连接。</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210908162034.png"></p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210908161927.png"></p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210908162144.png"></p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210908163405.png"></p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210908163643.png"></p>
<h3 id="关于GPIO的电源域"><a href="#关于GPIO的电源域" class="headerlink" title="关于GPIO的电源域"></a>关于GPIO的电源域</h3><p><img src="https://gitee.com/seekerwj/pic/raw/master/20210908164909.png"></p>
<p>即GPIO0~5都可以作为唤醒引脚</p>
<h3 id="利用GPIO输出点亮一个LED灯"><a href="#利用GPIO输出点亮一个LED灯" class="headerlink" title="利用GPIO输出点亮一个LED灯"></a>利用GPIO输出点亮一个LED灯</h3><p>我的板子上是利用这么几个IO口来控制LED灯的。可以很明显的看出，当GPIO为高电平的时候，LED灯会被点亮。</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210908154320.png"></p>
<h4 id="GPIO输出模式的配置过程"><a href="#GPIO输出模式的配置过程" class="headerlink" title="GPIO输出模式的配置过程"></a>GPIO输出模式的配置过程</h4><p>利用ESPIDF配置GPIO口是很简单的。</p>
<p>过程如下（最简单的方法）</p>
<pre class=" language-c"><code class="language-c"><span class="token function">gpio_pad_select_gpio</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 选择一个GPIO</span>
<span class="token function">gpio_set_direction</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把这个GPIO作为输出</span>
<span class="token function">gpio_set_level</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 设置这个GPIO的高低电平</span></code></pre>
<hr>
<p>使LED灯闪烁的方法</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/FreeRTOS.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/task.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"driver/gpio.h"</span></span>

<span class="token keyword">void</span> <span class="token function">app_main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">gpio_pad_select_gpio</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 选择一个GPIO</span>
    <span class="token function">gpio_set_direction</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 把这个GPIO作为输出</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token function">gpio_set_level</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 把这个GPIO输出低电平</span>
        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">/</span> portTICK_PERIOD_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_set_level</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">/</span> portTICK_PERIOD_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>以上涉及了一些FreeRTOS操作系统的相关函数和库，暂时先不用管，之后会做详细记录</p>
<p>只需知道<code>vTaskDelay(1000 / portTICK_PERIOD_MS)</code>这个函数是延迟1s就完事了。并且这个函数的使用需要<code>FreeRTOS.h</code>,<code>task.h</code>，这两个库的支持</p>
<hr>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h4 id><a href="#" class="headerlink" title></a><img src="https://z4a.net/images/2021/09/08/VID_20210908_160947.gif" alt="VID_20210908_160947.gif"></h4><hr>
<h3 id="利用GPIO的输入功能来检测按键是否按下"><a href="#利用GPIO的输入功能来检测按键是否按下" class="headerlink" title="利用GPIO的输入功能来检测按键是否按下"></a>利用GPIO的输入功能来检测按键是否按下</h3><p>我的板子上是使用这么两个IO口来检测按键的输入的。</p>
<p>GPIO9可以正常作为按键输入的检测。但是CHIP_EN脚是用作于ESP32的使能，失能脚，起到的是复位ESP32的作用。</p>
<p>所以这里选择的是GPIO9脚来作为按键输入的判断。（检测到低电平为按键按下）</p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210908161348.png" style="zoom:67%;">



<h4 id="GPIO输入模式的配置过程"><a href="#GPIO输入模式的配置过程" class="headerlink" title="GPIO输入模式的配置过程"></a>GPIO输入模式的配置过程</h4><p>同理，过程如下（简单方法）</p>
<pre class=" language-c"><code class="language-c"><span class="token function">gpio_pad_select_gpio</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 选择一个GPIO</span>
<span class="token function">gpio_set_direction</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">,</span> GPIO_MODE_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 把这个GPIO作为输入</span>
<span class="token function">gpio_get_level</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//获取GPIO的电平</span></code></pre>
<hr>
<p>获取按键是否按下的代码</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/FreeRTOS.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/task.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"driver/gpio.h"</span></span>

<span class="token keyword">void</span> <span class="token function">app_main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">gpio_pad_select_gpio</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_set_direction</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">,</span> GPIO_MODE_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" Current Gpio9 Level is : %d \r\n\r\n"</span><span class="token punctuation">,</span>
                <span class="token function">gpio_get_level</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取一次GPIO_NUM_9的电平</span>

        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">500</span> <span class="token operator">/</span> portTICK_PERIOD_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//每500ms检测一次是否有输入</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<hr>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><img src="https://z4a.net/images/2021/09/08/VID_20210908_170948.gif" alt="VID_20210908_170948.gif"></p>
<hr>
<h3 id="配置GPIO来检测中断"><a href="#配置GPIO来检测中断" class="headerlink" title="配置GPIO来检测中断"></a>配置GPIO来检测中断</h3><h4 id="首先要注意这几个函数"><a href="#首先要注意这几个函数" class="headerlink" title="首先要注意这几个函数"></a>首先要注意这几个函数</h4><pre class=" language-c"><code class="language-c">esp_err_t <span class="token function">gpio_isr_register</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                            <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> 
                            <span class="token keyword">int</span> intr_alloc_flags<span class="token punctuation">,</span> 
                            gpio_isr_handle_t <span class="token operator">*</span>handle<span class="token punctuation">,</span> <span class="token punctuation">)</span></code></pre>
<p>这个函数是为GPIO中断注册中断处理程序，这个中断程序会在任何GPIO发生中断的时候被调用。（一般情况下就不用这个函数，用下面的方法来配置GPIO的中断）</p>
<ul>
<li><strong>Parameters</strong> </li>
<li><code>fn</code>: 需要调用的中断函数<ul>
<li><code>intr_alloc_flags</code>: 用于分配中断的标志。</li>
</ul>
</li>
<li><code>arg</code>: 传入中断函数的参数<ul>
<li><code>handle</code>: 指向中断函数返回的句柄</li>
</ul>
</li>
</ul>
<pre class=" language-c"><code class="language-c">esp_err_t <span class="token function">gpio_install_isr_service</span><span class="token punctuation">(</span><span class="token keyword">int</span> intr_alloc_flags<span class="token punctuation">)</span></code></pre>
<p>这个函数用来为GPIO驱动注册中断服务，相当于GPIO中断的总开关。但是这个函数与<code>gpio_isr_register</code>不兼容。这个函数常常与<code>gpio_isr_handler_add </code>这个函数配合着使用。</p>
<p>其中的参数<code>intr_alloc_flags</code>相当于中断的优先级等级。也就是说，整个GPIO的外部输入中断的优先级都一样。不过仍然可以在GPIO中断处理函数中进行判断其优先级</p>
<pre class=" language-c"><code class="language-c">esp_err_t <span class="token function">gpio_isr_handler_add</span><span class="token punctuation">(</span>gpio_num_tgpio_num<span class="token punctuation">,</span> 
                               gpio_isr_tisr_handler<span class="token punctuation">,</span> 
                               <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span></code></pre>
<p>这个函数的作用是为某个GPIO口来绑定一个中断回调函数。</p>
<p>对于中断回调函数而言，不再需要为其声明<code>IRAM_ATTR</code>标志。 除非在<code>gpio_install_isr_service()</code>中分配ISR时传递<code>ESP_INTR_FLAG_IRAM</code>标志。</p>
<ul>
<li><strong>Parameters</strong><ul>
<li><code>gpio_num</code>: GPIO标号</li>
<li><code>isr_handler</code>: GPIO口的中断回调函数名</li>
<li><code>args</code>: 传入GPIO口的参数</li>
</ul>
</li>
</ul>
<h4 id="GPIO中断配置的过程"><a href="#GPIO中断配置的过程" class="headerlink" title="GPIO中断配置的过程"></a>GPIO中断配置的过程</h4><p>首先选定一个GPIO口</p>
<p>设置其输入/输出方向</p>
<p>使能其中断</p>
<p>设置中断的触发类型（见下表）</p>
<pre class=" language-c"><code class="language-c">GPIO_INTR_DISABLE <span class="token comment" spellcheck="true">//禁用GPIO中断</span>
GPIO_INTR_POSEDGE <span class="token comment" spellcheck="true">//GPIO中断类型：上升沿</span>
GPIO_INTR_NEGEDGE <span class="token comment" spellcheck="true">//下降沿</span>
GPIO_INTR_ANYEDGE <span class="token comment" spellcheck="true">//上升沿和下降沿</span>
GPIO_INTR_LOW_LEVEL <span class="token comment" spellcheck="true">//输入低电平触发</span>
GPIO_INTR_HIGH_LEVEL <span class="token comment" spellcheck="true">//输入高电平触发</span></code></pre>
<p>可选：设置GPIO的上下拉是否使能（上拉后，ESP32可以检测到GPIO的下降沿）。</p>
<p>相关函数如下</p>
<pre class=" language-c"><code class="language-c"><span class="token function">gpio_pad_select_gpio</span><span class="token punctuation">(</span>GPIO_NUM_36<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">gpio_set_direction</span><span class="token punctuation">(</span>GPIO_NUM_36<span class="token punctuation">,</span> GPIO_MODE_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">gpio_intr_enable</span><span class="token punctuation">(</span>GPIO_NUM_36<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">gpio_set_intr_type</span><span class="token punctuation">(</span>GPIO_NUM_36<span class="token punctuation">,</span> GPIO_INTR_NEGEDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">gpio_pullup_en</span><span class="token punctuation">(</span>GPIO_NUM_36<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<hr>
<p>目的：</p>
<p>​    利用一个按键通过中断的方式来控制LED的亮灭</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/FreeRTOS.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/task.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"driver/gpio.h"</span></span>

uint8_t flag<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//按键按下标志位</span>

<span class="token keyword">void</span> IRAM_ATTR <span class="token function">gpio_isr_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//GPIO中断回调函数</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   
    flag <span class="token operator">=</span> <span class="token operator">~</span>flag<span class="token punctuation">;</span>
    <span class="token function">gpio_set_level</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">,</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使GPIO5的电平翻转一次</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">app_main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//GPIO5------蓝色LED</span>
    <span class="token function">gpio_pad_select_gpio</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_set_direction</span><span class="token punctuation">(</span>GPIO_NUM_5<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//GPIO9------按键输入中断配置</span>
    <span class="token function">gpio_pad_select_gpio</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_set_direction</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">,</span> GPIO_MODE_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_intr_enable</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//使能GPIO9 上的中断</span>
    <span class="token function">gpio_set_intr_type</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">,</span> GPIO_INTR_NEGEDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//配置GPIO9 上中断触发源（下降沿）</span>
    <span class="token function">gpio_pullup_en</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//对GPIO9   上拉以便于检测到下降沿或者说低电平</span>

    <span class="token comment" spellcheck="true">//注册中断服务</span>
    <span class="token function">gpio_install_isr_service</span><span class="token punctuation">(</span>ESP_INTR_FLAG_LEVEL1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//设置GPIO的中断回调函数</span>
    <span class="token function">gpio_isr_handler_add</span><span class="token punctuation">(</span>GPIO_NUM_9<span class="token punctuation">,</span>gpio_isr_handler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">/</span> portTICK_PERIOD_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>具体的整个流程就是</p>
<ol>
<li>配置GPIO为输入模式</li>
<li>开启GPIO口中断</li>
<li>设置其中断触发源</li>
<li>配置其为上拉模式，以便于检测按键的下降沿</li>
<li>为GPIO驱动注册中断服务</li>
<li>编写GPIO的中断回调函数</li>
<li>设置GPIO的中断回调函数与GPIO口中断绑定</li>
<li></li>
</ol>
<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p><img src="https://z4a.net/images/2021/09/08/VID_20210908_220746.gif" alt="VID_20210908_220746.gif"></p>
<hr>
<h2 id="函数总结-便于查阅"><a href="#函数总结-便于查阅" class="headerlink" title="函数总结(便于查阅)"></a>函数总结(便于查阅)</h2><pre class=" language-c"><code class="language-c"><span class="token function">gpio_pad_select_gpio</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            用于选择需要配置的GPIO口

<span class="token function">gpio_set_direction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            用于设置GPIO的输入输出等模式

<span class="token function">gpio_set_level</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                用于设置GPIO口的电平

<span class="token function">gpio_get_level</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                用于获取指定GPIO口的电平

<span class="token function">gpio_intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                使能选中的GPIO中断

<span class="token function">gpio_set_intr_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            用于配置选定的GPIO口的中断触发方式

<span class="token function">gpio_pullup_en</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                用于使能GPIO口的上拉

<span class="token function">gpio_isr_register</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            用于为GPIO口注册中断<span class="token punctuation">(</span>不常用<span class="token punctuation">)</span>

<span class="token function">gpio_install_isr_service</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        用于为GPIO驱动注册中断

<span class="token function">gpio_isr_handler_add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            用于为GPIO口注册中断回调函数</code></pre>
<p><em>更多详细的GPIO相关函数还请参考：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.3/esp32c3/api-reference/peripherals/gpio.html?highlight=gpio#gpio-rtc-gpio">https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.3/esp32c3/api-reference/peripherals/gpio.html?highlight=gpio#gpio-rtc-gpio</a></em></p>
]]></content>
      <tags>
        <tag>ESP32-C3</tag>
      </tags>
  </entry>
  <entry>
    <title>EPS32 软件定时器的基本使用</title>
    <url>/2021/09/09/ESP32_C3%E8%BD%AF%E5%AE%9A%E6%97%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    esp_timer相当于一个高分辨率的软件定时器，并且可以将ESP32从睡眠中唤醒。可以将其类比为FreeRTOS的定时器，但是这二者之间也是有区别的。</p>
<p>​    FreeRTOS的定时器定时周期不得小于其RTOS的滴答周期，并且FreeRTOS的定时器是从一个优先级较低的任务中调用的（虽然这个任务的优先级也是可以调高的）。但是esp_timer就不受这两者的限制。</p>
<p>​    虽然如此但也是要注意，由于esp_timer回调函数的优先级很高，所以回调函数中不能执行很多命令（很大程度上会影响系统的实时性），还是老规矩，中断中尽量只是标记信号量，处理函数还是放到任务中去执行。</p>
<p>​    并且这个定时器的回调函数也是会被其他更高优先级的任务抢占的，比如说 SPI FALSH操作。但是这种一般可以暂时先不考虑。</p>
<p>​     周期性esp_timer还会对最小计时器周期施加50us的限制。周期小于50us的定期软件计时器不切实际，因为它们会占用大部分CPU时间。如果发现需要一个短周期的计时器，请考虑使用专用的硬件外设或DMA功能。（太短的定时也不太现实）</p>
<a id="more"></a>



<h2 id="利用esp-timer完成一次性定时"><a href="#利用esp-timer完成一次性定时" class="headerlink" title="利用esp_timer完成一次性定时"></a>利用esp_timer完成一次性定时</h2><h3 id="需要包含的库"><a href="#需要包含的库" class="headerlink" title="需要包含的库"></a>需要包含的库</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/FreeRTOS.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/task.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"esp_timer.h"</span></span></code></pre>
<h3 id="定义相关变量"><a href="#定义相关变量" class="headerlink" title="定义相关变量"></a>定义相关变量</h3><pre class=" language-c"><code class="language-c">esp_timer_handle_t timer_once_handle<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义一个定时器的句柄</span>

<span class="token comment" spellcheck="true">//这个结构体的作用就是配置定时器的回调函数以及为这个定时器起一个名字</span>
esp_timer_create_args_t timer_once_arg <span class="token operator">=</span> 
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> 
    <span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token operator">&amp;</span>timer_once_cb<span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 设置回调函数</span>
    <span class="token punctuation">.</span>arg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>                          <span class="token comment" spellcheck="true">// 不携带参数</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"TestOnceTimer"</span>               <span class="token comment" spellcheck="true">// 定时器名字</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

</code></pre>
<h3 id="编写定时器回调函数"><a href="#编写定时器回调函数" class="headerlink" title="编写定时器回调函数"></a>编写定时器回调函数</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//编写这个定时器的定时器回调函数</span>
<span class="token keyword">void</span> <span class="token function">timer_once_cb</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> 
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    int64_t tick <span class="token operator">=</span> <span class="token function">esp_timer_get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"方法回调名字: %s , 距离定时器开启时间间隔 = %lld \r\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> tick<span class="token punctuation">)</span><span class="token punctuation">;</span>
    esp_err_t err <span class="token operator">=</span> <span class="token function">esp_timer_delete</span><span class="token punctuation">(</span>timer_once_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"要删除的定时器名字：%s , 是否停止成功：%s"</span><span class="token punctuation">,</span> timer_once_arg<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
            err <span class="token operator">==</span> ESP_OK <span class="token operator">?</span> <span class="token string">"ok!\r\n"</span> <span class="token punctuation">:</span> <span class="token string">"failed!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p><code>__func__</code>这个函数是C++中的函数，作用就是获取当前调用函数的名字</p>
<h3 id="创建及启动定时器"><a href="#创建及启动定时器" class="headerlink" title="创建及启动定时器"></a>创建及启动定时器</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">app_main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">esp_timer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 使用定时器API函数，先调用接口初始化</span>

    <span class="token comment" spellcheck="true">//创建一个单次执行的定时器</span>
    <span class="token function">esp_timer_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_once_arg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer_once_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">esp_timer_start_once</span><span class="token punctuation">(</span>timer_once_handle<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里定时了1s</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">/</span> portTICK_PERIOD_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/FreeRTOS.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/task.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"esp_timer.h"</span></span>

esp_timer_handle_t timer_once_handle<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">timer_once_cb</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 定义一个单次运行的定时器结构体</span>
esp_timer_create_args_t timer_once_arg <span class="token operator">=</span> 
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> 
    <span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token operator">&amp;</span>timer_once_cb<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 设置回调函数</span>
    <span class="token punctuation">.</span>arg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>                      <span class="token comment" spellcheck="true">// 不携带参数</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"TestOnceTimer"</span>           <span class="token comment" spellcheck="true">// 定时器名字</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">timer_once_cb</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> 
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    int64_t tick <span class="token operator">=</span> <span class="token function">esp_timer_get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"方法回调名字: %s , 距离定时器开启时间间隔 = %lld \r\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> tick<span class="token punctuation">)</span><span class="token punctuation">;</span>
    esp_err_t err <span class="token operator">=</span> <span class="token function">esp_timer_delete</span><span class="token punctuation">(</span>timer_once_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"要删除的定时器名字：%s , 是否停止成功：%s"</span><span class="token punctuation">,</span> timer_once_arg<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
            err <span class="token operator">==</span> ESP_OK <span class="token operator">?</span> <span class="token string">"ok!\r\n"</span> <span class="token punctuation">:</span> <span class="token string">"failed!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">app_main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">esp_timer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用定时器API函数，先调用接口初始化</span>

    <span class="token comment" spellcheck="true">//创建一个单次执行的定时器</span>
    <span class="token function">esp_timer_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_once_arg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer_once_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">esp_timer_start_once</span><span class="token punctuation">(</span>timer_once_handle<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里定时了10s</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">/</span> portTICK_PERIOD_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://gitee.com/seekerwj/pic/raw/master/20210909214957.png"></p>
<h2 id="利用esp-timer实现周期定时器"><a href="#利用esp-timer实现周期定时器" class="headerlink" title="利用esp_timer实现周期定时器"></a>利用esp_timer实现周期定时器</h2><p>利用esp_timer实现周期定时器也是十分的简单，只需要将原函数中的<code>esp_timer_start_once</code>函数变为<code>esp_timer_start_periodic</code>即可。</p>
<p>重新启动呢？重新再调用函数<code>esp_timer_start_periodic</code>即可完成重启的过程，并且定时计数器并不会清零。（这个64位的计时器如果要是清零的话那得584,942年，几辈子不断电都加不满，所以不用担心计数溢出的问题。）</p>
<p>这里使用周期性定时器来实现了一个2s的定时器，在其完成了10s的定时之后将调用函数<code>esp_timer_stop</code>将其停止，并设置了一个标志位，同时在主循环函数中再次将其开启。（周期循环这个过程）</p>
<p>具体代码如下</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/FreeRTOS.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/task.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"esp_timer.h"</span></span>

esp_timer_handle_t timer_period_handle<span class="token punctuation">;</span>
uint8_t flag<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">timer_period_cb</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 定义一个单次运行的定时器结构体</span>
esp_timer_create_args_t timer_period_arg <span class="token operator">=</span> 
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> 
    <span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token operator">&amp;</span>timer_period_cb<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 设置回调函数</span>
    <span class="token punctuation">.</span>arg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>                      <span class="token comment" spellcheck="true">// 不携带参数</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"TestPeriodTimer"</span>           <span class="token comment" spellcheck="true">// 定时器名字</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">timer_period_cb</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> 
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> uint8_t time<span class="token punctuation">;</span>

    int64_t tick <span class="token operator">=</span> <span class="token function">esp_timer_get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"方法回调名字: %s , 距离定时器开启时间间隔 = %lld \r\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> tick<span class="token punctuation">)</span><span class="token punctuation">;</span>

    time<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>time <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 停止定时器工作，并获取是否停止成功</span>
        esp_err_t err <span class="token operator">=</span> <span class="token function">esp_timer_stop</span><span class="token punctuation">(</span>timer_period_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"要停止的定时器名字：%s , 是否停止成功：%s"</span><span class="token punctuation">,</span> timer_period_arg<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
                err <span class="token operator">==</span> ESP_OK <span class="token operator">?</span> <span class="token string">"ok!\r\n"</span> <span class="token punctuation">:</span> <span class="token string">"failed!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// err = esp_timer_delete(timer_period_handle);</span>
        <span class="token comment" spellcheck="true">// printf("要删除的定时器名字：%s , 是否停止成功：%s", timer_period_arg.name,</span>
        <span class="token comment" spellcheck="true">//         err == ESP_OK ? "ok!\r\n" : "failed!\r\n");</span>

        flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">app_main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">esp_timer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用定时器API函数，先调用接口初始化</span>

    <span class="token comment" spellcheck="true">//创建一个单次执行的定时器</span>
    <span class="token function">esp_timer_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_period_arg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer_period_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">esp_timer_start_periodic</span><span class="token punctuation">(</span>timer_period_handle<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里定时了10s</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//要是停止了，5s之后函数中会再次启动这个函数</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token function">esp_timer_start_periodic</span><span class="token punctuation">(</span>timer_period_handle<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里定时了10s</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">5000</span> <span class="token operator">/</span> portTICK_PERIOD_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p><img src="https://gitee.com/seekerwj/pic/raw/master/20210909223334.png"></p>
<h2 id="使用ESP32软定时器的思路"><a href="#使用ESP32软定时器的思路" class="headerlink" title="使用ESP32软定时器的思路"></a>使用ESP32软定时器的思路</h2><ol>
<li>首先先定义一个定时器的句柄变量<code>esp_timer_handle_t xxx</code></li>
<li>为这个定时器编写一个中断回调函数</li>
<li>定义一个结构体用于将回调函数与定时器绑定起来<code>esp_timer_create_args_t</code></li>
<li>在主函数中使用<code>esp_timer_init();</code>来初始化定时器</li>
<li>利用函数<code>esp_timer_create</code>来为之前的定时器句柄创建一个定时器</li>
<li>利用<code>esp_timer_start_once</code>或者<code>esp_timer_start_periodic</code>函数来按要求启动定时器</li>
<li>根据用户需求自行调用定时器删除或者停止函数。</li>
</ol>
<h2 id="函数总结-便于查阅"><a href="#函数总结-便于查阅" class="headerlink" title="函数总结(便于查阅)"></a>函数总结(便于查阅)</h2><pre class=" language-c"><code class="language-c">用于初始化定时器（一般在函数初始化时使用）
esp_err_t <span class="token function">esp_timer_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                

用于注销定时器（一般不使用）
esp_err_t <span class="token function">esp_timer_deinit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                

用于创建一个定时器（在不再需要定时器时应该将其删除）    
esp_err_t <span class="token function">esp_timer_create</span><span class="token punctuation">(</span>constesp_timer_create_args_t <span class="token operator">*</span>create_args<span class="token punctuation">,</span> esp_timer_handle_t <span class="token operator">*</span>out_handle<span class="token punctuation">)</span>    

开启一次性定时器（调用此函数时，定时器应该处于停止状态）    
esp_err_t <span class="token function">esp_timer_start_once</span><span class="token punctuation">(</span>esp_timer_handle_ttimer<span class="token punctuation">,</span> uint64_t timeout_us<span class="token punctuation">)</span>    

开启一个周期定时器（调用此函数时，定时器应该处于停止状态）    
esp_err_t <span class="token function">esp_timer_start_periodic</span><span class="token punctuation">(</span>esp_timer_handle_ttimer<span class="token punctuation">,</span> uint64_t period<span class="token punctuation">)</span>    

停止一个定时器（但是不会使其计数值清零）    
esp_err_t <span class="token function">esp_timer_stop</span><span class="token punctuation">(</span>esp_timer_handle_ttimer<span class="token punctuation">)</span>    

删除一个定时器（删除定时器时，定时器应处于停止状态，可以先使其停止再删除）    
esp_err_t <span class="token function">esp_timer_delete</span><span class="token punctuation">(</span>esp_timer_handle_ttimer<span class="token punctuation">)</span>    

获取当前定时器的计数值（定时器自启动以来的技术值）    
int64_t <span class="token function">esp_timer_get_time</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>    </code></pre>
<p><em>更多的esp_timer相关的函数以及介绍还请参考：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32c3/api-reference/system/esp_timer.html?highlight=esp_timer_get_time#high-resolution-timer">https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32c3/api-reference/system/esp_timer.html?highlight=esp_timer_get_time#high-resolution-timer</a></em></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><code>esp_timer_start_periodic</code>以及<code>esp_timer_start_once</code>的定时周期都是以<code>us</code>为单位的。</p>
]]></content>
      <tags>
        <tag>ESP32-C3</tag>
      </tags>
  </entry>
  <entry>
    <title>EPS32 串口的基本使用</title>
    <url>/2021/09/11/ESP32_C3%E4%B8%B2%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="使用串口的基本流程"><a href="#使用串口的基本流程" class="headerlink" title="使用串口的基本流程"></a>使用串口的基本流程</h2><ol>
<li>使用结构体<code>uart_config_t </code>来为串口设置参数（波特率，停止位，是否有奇偶校验等）</li>
<li>利用函数<code>uart_set_pin</code>来设置串口的引脚映射（没有映射的话就默认为原来的）ESP32的串口管脚可以任意映射到其他管脚上，就是说任意两个PIN脚都可以作为串口的输出输入脚来使用</li>
<li>利用函数<code>uart_driver_install</code>来为ESP32安装串口驱动</li>
<li>串口应用函数的使用，即按照用户要求在任务中调用串口的收发函数</li>
<li>使用串口的中断（可选）</li>
<li>串口卸载（基本不常用）</li>
</ol>
<a id="more"></a>

<h2 id="设置串口参数"><a href="#设置串口参数" class="headerlink" title="设置串口参数"></a>设置串口参数</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> baud_rate<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">/*串口波特率*/</span>
    uart_word_length_t data_bits<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/*串口字长*/</span>
    uart_parity_t parity<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/*是否启动串口的奇偶校验*/</span>
    uart_stop_bits_t stop_bits<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/*串口的停止位*/</span>
    uart_hw_flowcontrol_t flow_ctrl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*是否启动串口的流控位*/</span>
    uint8_t rx_flow_ctrl_thresh<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*UART HW RTS阈值*/</span>不常用
    <span class="token keyword">union</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        uart_sclk_t source_clk<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/*UART源时钟选择*/</span>
        bool use_ref_tick  <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>deprecated<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*!&lt; Deprecated method to select ref tick clock source, set source_clk field instead */</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> uart_config_t<span class="token punctuation">;</span></code></pre>
<p>​    利用该结构体为串口配置基本参数，如设置波特率、数据位、停止位等 </p>
<h2 id="串口配置引脚"><a href="#串口配置引脚" class="headerlink" title="串口配置引脚"></a>串口配置引脚</h2><pre class=" language-c"><code class="language-c">esp_err_t <span class="token function">uart_set_pin</span><span class="token punctuation">(</span>uart_port_tuart_num<span class="token punctuation">,</span> 
                       <span class="token keyword">int</span> tx_io_num<span class="token punctuation">,</span> 
                       <span class="token keyword">int</span> rx_io_num<span class="token punctuation">,</span> 
                       <span class="token keyword">int</span> rts_io_num<span class="token punctuation">,</span>
                       <span class="token keyword">int</span> cts_io_num<span class="token punctuation">)</span></code></pre>
<ul>
<li><p><strong>参数</strong></p>
<ul>
<li>uart_num: 是哪个串口</li>
<li>tx_io_num: UART TX pin GPIO number.</li>
<li>rx_io_num: UART RX pin GPIO number.</li>
<li>rts_io_num: UART RTS pin GPIO number.</li>
<li>cts_io_num: UART CTS pin GPIO number.</li>
</ul>
</li>
</ul>
<p>如果不需要映射的话，将管脚参数设置为<code>UART_PIN_NO_CHANGE</code>就好</p>
<h2 id="串口驱动的安装"><a href="#串口驱动的安装" class="headerlink" title="串口驱动的安装"></a>串口驱动的安装</h2><h3 id="函数uart-driver-install"><a href="#函数uart-driver-install" class="headerlink" title="函数uart_driver_install()"></a>函数uart_driver_install()</h3><pre class=" language-c"><code class="language-c">esp_err_t <span class="token function">uart_driver_install</span><span class="token punctuation">(</span>uart_port_t uart_num<span class="token punctuation">,</span> 
                              <span class="token keyword">int</span> rx_buffer_size<span class="token punctuation">,</span> 
                              <span class="token keyword">int</span> tx_buffer_size<span class="token punctuation">,</span> 
                              <span class="token keyword">int</span> queue_size<span class="token punctuation">,</span> 
                              QueueHandle_t <span class="token operator">*</span>uart_queue<span class="token punctuation">,</span> 
                              <span class="token keyword">int</span> intr_alloc_flags<span class="token punctuation">)</span></code></pre>
<ul>
<li><strong>参数</strong><ul>
<li>uart_num: 串口号（用的哪个串口就选哪个）</li>
<li>rx_buffer_size: 串口接收环缓冲区大小 </li>
<li>tx_buffer_size: 串口发送环缓冲区大小(如果设置为0，驱动程序将不使用TX缓冲区，TX函数将阻塞任务，直到所有数据发送完毕)。</li>
<li>queue_size: 队列长度。</li>
<li>uart_queue: 串口事件队列的句柄</li>
<li>intr_alloc_flags: 分配中断的标志</li>
</ul>
</li>
</ul>
<h2 id="运行UART通讯"><a href="#运行UART通讯" class="headerlink" title="运行UART通讯"></a>运行UART通讯</h2><p>串行通信由每个UART控制器的有限状态机（FSM）控制。</p>
<p>发送数据的过程涉及以下步骤：</p>
<p>将数据写入Tx FIFO缓冲区<br>FSM序列化数据<br>FSM将数据发送出去<br>接收数据的过程类似，但是步骤相反：</p>
<p>FSM处理传入的串行流并将其并行化<br>FSM将数据写入Rx FIFO缓冲区<br>从Rx FIFO缓冲区读取数据<br>因此，应用程序将被限制为分别使用<code>uart_write_bytes()</code>和从相应的缓冲区写入和读取数据<code>uart_read_bytes()</code>，而FSM将完成其余的工作。</p>
<h3 id="函数uart-read-bytes"><a href="#函数uart-read-bytes" class="headerlink" title="函数uart_read_bytes()"></a>函数uart_read_bytes()</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uart_read_bytes</span><span class="token punctuation">(</span>uart_port_t uart_num<span class="token punctuation">,</span> 
                    <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> 
                    uint32_t length<span class="token punctuation">,</span> 
                    TickType_t ticks_to_wait<span class="token punctuation">)</span></code></pre>
<ul>
<li><strong>参数</strong><ul>
<li>uart_num: 串口号</li>
<li>buf: 用于存放读取到数据的缓冲区</li>
<li>length: 需要读取的长度</li>
<li>ticks_to_wait: 阻塞时间（在这个时间内任务会阻塞，直到读满长度为length的数据后，或者超时）</li>
</ul>
</li>
<li><strong>返回值</strong><ul>
<li>(-1): 读取失败</li>
<li>其他: 返回从串口缓冲区读取到的字节数</li>
</ul>
</li>
</ul>
<h3 id="函数uart-write-bytes"><a href="#函数uart-write-bytes" class="headerlink" title="函数uart_write_bytes()"></a>函数uart_write_bytes()</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uart_write_bytes</span><span class="token punctuation">(</span>uart_port_t uart_num<span class="token punctuation">,</span> 
                     <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> 
                     size_t size<span class="token punctuation">)</span></code></pre>
<ul>
<li><strong>参数</strong><ul>
<li>uart_num: 串口号</li>
<li>src: 需要发送数据的地址</li>
<li>size: 需要发送的长度</li>
</ul>
</li>
<li><strong>返回值</strong><ul>
<li>(-1): 发送失败</li>
<li>其他: 发送到TX FIFO的字节数</li>
</ul>
</li>
</ul>
<h2 id="串口队列接收"><a href="#串口队列接收" class="headerlink" title="串口队列接收"></a>串口队列接收</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* UART Events Example

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/FreeRTOS.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/task.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"freertos/queue.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"driver/uart.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"esp_log.h"</span></span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>TAG <span class="token operator">=</span> <span class="token string">"uart_events"</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * This example shows how to use the UART driver to handle special UART events.
 *
 * It also reads data from UART0 directly, and echoes it to console.
 *
 * - Port: UART0
 * - Receive (Rx) buffer: on
 * - Transmit (Tx) buffer: off
 * - Flow control: off
 * - Event queue: on
 * - Pin assignment: TxD (default), RxD (default)
 */</span>

<span class="token macro property">#<span class="token directive keyword">define</span> EX_UART_NUM UART_NUM_0</span>
<span class="token macro property">#<span class="token directive keyword">define</span> PATTERN_CHR_NUM    (3)         </span><span class="token comment" spellcheck="true">/*!&lt; Set the number of consecutive and identical characters received by receiver which defines a UART pattern*/</span>

<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE (1024)</span>
<span class="token macro property">#<span class="token directive keyword">define</span> RD_BUF_SIZE (BUF_SIZE)</span>

<span class="token keyword">static</span> QueueHandle_t uart0_queue<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uart_event_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    uart_event_t event<span class="token punctuation">;</span>
    size_t buffered_size<span class="token punctuation">;</span>
    uint8_t<span class="token operator">*</span> dtmp <span class="token operator">=</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span>RD_BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//Waiting for UART event.</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">xQueueReceive</span><span class="token punctuation">(</span>uart0_queue<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>event<span class="token punctuation">,</span> <span class="token punctuation">(</span>portTickType<span class="token punctuation">)</span>portMAX_DELAY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token function">bzero</span><span class="token punctuation">(</span>dtmp<span class="token punctuation">,</span> RD_BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"uart[%d] event:"</span><span class="token punctuation">,</span> EX_UART_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">switch</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//Event of UART receving data</span>
                <span class="token comment" spellcheck="true">/*We'd better handler data event fast, there would be much more data events than
                other types of events. If we take too much time on data event, the queue might
                be full.*/</span>
                <span class="token keyword">case</span> UART_DATA<span class="token punctuation">:</span>
                    <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"[UART DATA]: %d"</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">uart_read_bytes</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> dtmp<span class="token punctuation">,</span> event<span class="token punctuation">.</span>size<span class="token punctuation">,</span> portMAX_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"[DATA EVT]:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">uart_write_bytes</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> dtmp<span class="token punctuation">,</span> event<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//Event of HW FIFO overflow detected</span>
                <span class="token keyword">case</span> UART_FIFO_OVF<span class="token punctuation">:</span>
                    <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"hw fifo overflow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// If fifo overflow happened, you should consider adding flow control for your application.</span>
                    <span class="token comment" spellcheck="true">// The ISR has already reset the rx FIFO,</span>
                    <span class="token comment" spellcheck="true">// As an example, we directly flush the rx buffer here in order to read more data.</span>
                    <span class="token function">uart_flush_input</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">xQueueReset</span><span class="token punctuation">(</span>uart0_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//Event of UART ring buffer full</span>
                <span class="token keyword">case</span> UART_BUFFER_FULL<span class="token punctuation">:</span>
                    <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"ring buffer full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// If buffer full happened, you should consider encreasing your buffer size</span>
                    <span class="token comment" spellcheck="true">// As an example, we directly flush the rx buffer here in order to read more data.</span>
                    <span class="token function">uart_flush_input</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">xQueueReset</span><span class="token punctuation">(</span>uart0_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//Event of UART RX break detected</span>
                <span class="token keyword">case</span> UART_BREAK<span class="token punctuation">:</span>
                    <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"uart rx break"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//Event of UART parity check error</span>
                <span class="token keyword">case</span> UART_PARITY_ERR<span class="token punctuation">:</span>
                    <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"uart parity error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//Event of UART frame error</span>
                <span class="token keyword">case</span> UART_FRAME_ERR<span class="token punctuation">:</span>
                    <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"uart frame error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//UART_PATTERN_DET</span>
                <span class="token keyword">case</span> UART_PATTERN_DET<span class="token punctuation">:</span>
                    <span class="token function">uart_get_buffered_data_len</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffered_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">uart_pattern_pop_pos</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"[UART PATTERN DETECTED] pos: %d, buffered size: %d"</span><span class="token punctuation">,</span> pos<span class="token punctuation">,</span> buffered_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        <span class="token comment" spellcheck="true">// There used to be a UART_PATTERN_DET event, but the pattern position queue is full so that it can not</span>
                        <span class="token comment" spellcheck="true">// record the position. We should set a larger queue size.</span>
                        <span class="token comment" spellcheck="true">// As an example, we directly flush the rx buffer here.</span>
                        <span class="token function">uart_flush_input</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        <span class="token function">uart_read_bytes</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> dtmp<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">/</span> portTICK_PERIOD_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        uint8_t pat<span class="token punctuation">[</span>PATTERN_CHR_NUM <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        <span class="token function">memset</span><span class="token punctuation">(</span>pat<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">uart_read_bytes</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> pat<span class="token punctuation">,</span> PATTERN_CHR_NUM<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">/</span> portTICK_PERIOD_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"read data: %s"</span><span class="token punctuation">,</span> dtmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"read pat : %s"</span><span class="token punctuation">,</span> pat<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//Others</span>
                <span class="token keyword">default</span><span class="token punctuation">:</span>
                    <span class="token function">ESP_LOGI</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"uart event type: %d"</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>dtmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dtmp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">vTaskDelete</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">app_main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">esp_log_level_set</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> ESP_LOG_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* Configure parameters of an UART driver,
     * communication pins and install the driver */</span>
    uart_config_t uart_config <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span>baud_rate <span class="token operator">=</span> <span class="token number">115200</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>data_bits <span class="token operator">=</span> UART_DATA_8_BITS<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>parity <span class="token operator">=</span> UART_PARITY_DISABLE<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>stop_bits <span class="token operator">=</span> UART_STOP_BITS_1<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>flow_ctrl <span class="token operator">=</span> UART_HW_FLOWCTRL_DISABLE<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>source_clk <span class="token operator">=</span> UART_SCLK_APB<span class="token punctuation">,</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//Install UART driver, and get the queue.</span>
    <span class="token function">uart_driver_install</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> BUF_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> BUF_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>uart0_queue<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">uart_param_config</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uart_config<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//Set UART log level</span>
    <span class="token function">esp_log_level_set</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> ESP_LOG_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//Set UART pins (using UART0 default pins ie no changes.)</span>
    <span class="token function">uart_set_pin</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> UART_PIN_NO_CHANGE<span class="token punctuation">,</span> UART_PIN_NO_CHANGE<span class="token punctuation">,</span> UART_PIN_NO_CHANGE<span class="token punctuation">,</span> UART_PIN_NO_CHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//Set uart pattern detect function.</span>
    <span class="token function">uart_enable_pattern_det_baud_intr</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">,</span> PATTERN_CHR_NUM<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//Reset the pattern queue length to record at most 20 pattern positions.</span>
    <span class="token function">uart_pattern_queue_reset</span><span class="token punctuation">(</span>EX_UART_NUM<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//Create a task to handler UART event from ISR</span>
    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>uart_event_task<span class="token punctuation">,</span> <span class="token string">"uart_event_task"</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    与普通串口初始化一样，不过串口的队列接收过程中多了队列这个缓冲。</p>
<p>​    串口的队列接收可以实现串口的不定长接收。并且对于数据处理的方式上更灵活（具体情况具体讨论）</p>
<p>​    创建一个串口队列，利用串口安装函数将其注册，之后只需要设置一个任务优先级较高的任务利用阻塞检测串口事件的方式就可以知道串口FIFO中是否有消息。当只有消息的时候才读取。这样就相当于一个中断了。</p>
<p>​    并且可以通过配置串口接收消息数目来达到接收固定数目消息中断的效果</p>
<p>之后利用该函数为串口注册中断函数也是可以的</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210911151816.png"></p>
<p>​    </p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>串口的使用也很简单</p>
<ol>
<li>设置串口参数</li>
<li>设置串口引脚</li>
<li>安装串口驱动</li>
<li>使用串口函数</li>
<li>使用中断（可选）</li>
<li>删除串口驱动（可选）</li>
</ol>
<p>测试下串口的中断使用</p>
<p>串口的队列接收消息的方式还需要配合事件标志组来进行，这里ESPIDF配合着FreeRTOS在串口方面创建了一个串口事件 uart_event_t  </p>
<p>创建了一个串口队列（相当于之前的STM32的串口缓冲区），用于缓冲接收到的消息。</p>
<p>这里有个疑问，使用<code>uart_read_bytes</code>这个函数之后是否串口的FIFO缓冲区就被清除了呢？–&gt;应该是的</p>
<p>对于ESP32来说，利用队列来接收串口发送的消息也是一种很好的形式。不需要在额外的开中断了。只需要把队列接收的任务的优先级调成最高级的优先级，之后使用<code>xQueueReceive</code>这个队列接收函数来长时间的阻塞接收任务（只有队列中又消息的时候才执行任务）。</p>
<p>​    之后根据串口事件类型<code>uart_event_t</code> <code>event.type</code>就可以根据不同的队列接收类型来对队列中接收到的消息来进行处理了。</p>
<p>​    其实这个串口的消息队列也不需要有多长，只需要满足接收消息的最大的值就可以了，并且可以通过<code>event.size</code>来知道此时队列中接收了多少消息    </p>
<p>懂了，串口协议还要再看下，ESP32是怎么知道串口接收完成的，这里利用了识别串口的结束位的方式才完成这个任务，并且也根据这个原理知道这个串口接收数据的长度。</p>
<p>ESP32利用这种方式配合着FreeRTOS队列的方式完成了</p>
<p>但是为什么这个串口只能接收120个字符？虽然也能完成接下来的接收并且能串起来，但为什么是120个字符？还是说限定时间内</p>
<p>罪魁祸首找到了,再<code>uart_driver_install</code>这个函数中，设置了最大接收数量，但是这个<code>UART_FULL_THRESH_DEFAULT</code>被默认为了120。考虑到这是自带的ESPIDF的库文件，还是不要修改的比较好。但是其实这也无伤大雅。数据小了写，但是仍然可以接收完成一次完成的数据帧。如果之后有需求再想办法就是了… 暂时就先这样吧</p>
<p><img src="https://gitee.com/seekerwj/pic/raw/master/20210911141836.png"></p>
<img src="https://gitee.com/seekerwj/pic/raw/master/20210911141932.png" style="zoom:50%;">

<p>解决办法</p>
<p>通过在结构<code>uart_intr_config_t</code>中输入缓冲区长度和超时各自的阈值并调用<code>uart_intr_config()</code>来配置它们   </p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​    暂时就先这样子吧…</p>
<p>​    利用ESPIDF编程指南配合着乐鑫官方提供的例程来学习也是蛮不错的….</p>
<p>​    对于ESP32的串口而言，还可以加入<code>uart_enable_pattern_det_baud_intr</code>这类函数（作用是接收到固定字符进进入中断），这样就能实现类似于AT这样的指令操作了，如果单将ESP32作为一个蓝牙/WIFI模块来配合着其他单片机使用的话这样子是不错的一个选择。</p>
]]></content>
      <tags>
        <tag>ESP32-C3</tag>
      </tags>
  </entry>
</search>
